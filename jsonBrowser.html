<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Structured Data Browser</title>
<style>
/* --- START OF FILE basic.css --- */

/* =============================================
   Global & Body Styles
   ============================================= */
* {
  box-sizing: border-box;
}

body {
  font-family: 'Consolas', monospace;
  margin: 0;
  padding: 20px;
  background: #f8f9fa;
}

/* =============================================
   Layout & Main Containers
   ============================================= */

/* Header Area */
.header {
  position: sticky;
  top: 0;
  background: #fff;
  padding: 10px 15px;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  margin-bottom: 20px;
  display: flex;
  gap: 15px; /* Space between groups */
  align-items: center;
  flex-wrap: wrap; /* Allow groups to wrap */
  z-index: 200;
}

/* Header Control Groups */
.search-group,
.view-controls-group,
.function-controls-group {
  display: flex;
  align-items: center;
  gap: 8px; /* Space between items within a group */
  flex-wrap: nowrap; /* Default, buttons within a group don't wrap unless specified in media query */
}

.search-group {
  flex-grow: 1; /* Allow search group to take more space */
  min-width: 280px; /* Minimum width for search group */
}

.view-controls-group,
.function-controls-group {
  flex-shrink: 0; /* Prevent these groups from shrinking excessively */
}

/* Responsive adjustments for header groups */
@media (max-width: 1250px) { /* Breakpoint where groups might start to feel crowded */
  .search-group,
  .view-controls-group,
  .function-controls-group {
    flex-wrap: wrap; /* Allow buttons to wrap within groups */
  }
}
@media (max-width: 768px) { /* More aggressive stacking for smaller screens */
    .header {
        /* flex-direction: column; /* Uncomment to stack groups vertically */
        /* align-items: stretch;   /* Uncomment for full-width groups when stacked */
    }
    .search-info {
        margin-left: 0; /* Reset margin for stacked layout */
        width: 100%;    /* Take full width in stacked layout */
        text-align: left; /* Or center, as preferred */
        padding-top: 10px;
    }
}

/* Scrollable viewport for the main table */
.json-table {
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  max-height: calc(100vh - 120px); /* Adjusted based on typical header height */
  overflow-y: auto;
  overflow-x: auto;
  width: 100%;
}

/* Modal Container */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

/* =============================================
   Interactive Elements (Header Specific)
   ============================================= */

/* Generic Button Base Style for Header */
.header button {
  padding: 7px 12px;
  margin: 0;
  border: 1px solid transparent;
  border-radius: 5px;
  color: white;
  cursor: pointer;
  font-size: 12px;
  font-weight: 500;
  transition: background-color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
  white-space: nowrap;
  line-height: 1.5;
}

.header button:disabled {
  background-color: #adb5bd !important; /* More distinct disabled color */
  border-color: #adb5bd !important;
  color: #f8f9fa !important;
  cursor: not-allowed;
  opacity: 0.65;
}

/* Search Group Styles */
.search-box {
  flex-grow: 1;
  min-width: 150px;
  padding: 8px 12px;
  border: 2px solid #ced4da;
  border-radius: 5px;
  font-size: 13px;
}

.search-box:focus {
  outline: none;
  border-color: #80bdff;
  box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

.search-button { /* Dedicated Search Button */
  background-color: #007bff; /* Primary blue */
  border-color: #007bff;
}
.search-button:hover {
  background-color: #0056b3;
  border-color: #0056b3;
}

.search-nav {
  display: flex;
  align-items: center;
  gap: 4px; /* Adds a small 4px gap between the previous and next buttons */
}

.search-nav button { /* Prev/Next */
  background-color: #6c757d; /* Grey */
  border-color: #6c757d;
  width: 30px;
  height: 30px;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}
.search-nav button:hover {
  background-color: #5a6268;
  border-color: #545b62;
}

/* View Controls Group Styles (e.g., for layout, display options) */
.view-controls-group button {
  background-color: #17a2b8; /* Teal/Info */
  border-color: #17a2b8;
}
.view-controls-group button:hover {
  background-color: #117a8b;
  border-color: #10707f;
}
.view-controls-group button.active {
  background-color: #138496;
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);
}

/* Function Controls Group Styles (e.g., for actions, data manipulation) */
.function-controls-group button {
  background-color: #6f42c1; /* Purple - for general functions */
  border-color: #6f42c1;
}
.function-controls-group button:hover {
  background-color: #59369a;
  border-color: #53338f;
}

/* Special function buttons within Function Group */
.function-controls-group .edit-mode-btn {
  background-color: #ffc107; /* Amber/Warning */
  border-color: #ffc107;
  color: #212529;
}
.function-controls-group .edit-mode-btn:hover {
  background-color: #e0a800;
  border-color: #d39e00;
}
.function-controls-group .edit-mode-btn.active {
  background-color: #28a745; /* Green for active "Done Editing" state */
  border-color: #28a745;
  color: white;
}
.function-controls-group .add-column-btn {
  background-color: #20c997; /* A different shade of teal for add */
  border-color: #20c997;
}
.function-controls-group .add-column-btn:hover {
  background-color: #1baa80;
  border-color: #189c73;
}
/* Visibility states for Add Column button */
.add-column-btn.hidden-button {
    visibility: hidden;
    opacity: 0;
    pointer-events: none;
}
.add-column-btn.visible { /* May not be strictly necessary if default is visible */
    visibility: visible;
    opacity: 1;
}

.function-controls-group button[data-action="show-csv"] { /* Specific style for Export CSV */
    background-color: #fd7e14; /* Orange */
    border-color: #fd7e14;
}
.function-controls-group button[data-action="show-csv"]:hover {
    background-color: #e36702;
    border-color: #d96102;
}

/* Info text in Header */
.search-info {
  font-size: 12px;
  color: #495057; /* Darker grey for better readability */
  white-space: nowrap;
  margin-left: auto; /* Push search info to the right */
  padding: 8px 5px; /* Align vertically a bit better */
  align-self: center; /* Ensure vertical alignment with other items if header wraps */
  min-width: 150px; /* Prevent excessive shrinking/jumping when content changes */
  text-align: left;
}

.hidden-indicator {
  color: #c82333;
  font-size: 11px;
  margin-left: 8px;
  font-weight: bold;
}

/* =============================================
   Main Table Styles
   ============================================= */

.json-table > table {
  width: auto;
  min-width: 100%;
  border-collapse: collapse;
  table-layout: auto;
}

.json-table > table > thead > tr > th {
  background: #f8f9fa;
  font-weight: 600;
  cursor: pointer;
  user-select: none;
  position: sticky;
  top: 0;
  z-index: 100;
  white-space: nowrap;
  padding: 10px 12px;
  text-align: left;
  border-bottom: 1px solid #dee2e6;
  font-size: 13px;
  min-width: 150px;
  vertical-align: top;
}

.json-table > table > thead > tr > th:hover {
  background: #e9ecef;
}

.json-table > table > thead > tr > th > div {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.json-table > table > thead > tr > th.sorted::after {
  content: ' ↓';
  color: #007bff;
}

.json-table > table > thead > tr > th.sorted.asc::after {
  content: ' ↑';
}

th.dragging {
  opacity: 0.4;
  background: #e9ecef !important;
}

th.drag-over {
  outline: 2px dashed #007bff;
  outline-offset: -2px;
  background-color: #dfefff !important;
}

.remove-col-btn-header {
  margin-left: 5px;
  padding: 1px 5px;
  font-size: 11px;
  line-height: 1.2;
  font-weight: bold;
  cursor: pointer;
  background-color: #dc3545;
  color: white;
  border: none;
  border-radius: 3px;
  vertical-align: middle;
}

.remove-col-btn-header:hover {
  background-color: #c82333;
}

.json-table > table > tbody > tr > td {
  padding: 9px 12px;
  text-align: left;
  border-bottom: 1px solid #e9ecef;
  font-size: 13px;
  min-width: 150px;
  word-wrap: break-word;
  overflow-wrap: break-word;
  vertical-align: top;
}

.json-table > table > tbody > tr:nth-child(even) {
  background: #f8f9fa;
}

.json-table > table > tbody > tr:hover {
  background: #e6f7ff;
}

.row-number {
  text-align: center;
  width: 50px !important;
  min-width: 50px !important;
  max-width: 50px !important;
  position: sticky;
  left: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: normal; /* Changed from nowrap to normal to allow potential wrapping if content forces it despite fixed width */
}

.json-table > table > thead > tr > th.row-number {
  font-weight: 600;
  color: #495057;
  background: #f1f3f5;
  z-index: 150; /* Higher than regular th for sticky behavior */
  border-right: 1px solid #dee2e6;
}

.json-table > table > tbody > tr > td.row-number {
  font-weight: normal;
  color: #495057;
  background: #f8f9fa; /* Base background for row number cell */
  z-index: 90; /* Higher than regular td for sticky behavior */
  border-right: 1px solid #e9ecef;
}
.json-table > table > tbody > tr:nth-child(even) > td.row-number {
  background: #e9ecef; /* Match even row striping, slightly adjusted */
}

/* =============================================
   Expandable / Nested Content Styles
   ============================================= */

.expandable {
  cursor: pointer;
  position: relative;
  background: #fff0e1;
  border-left: 3px solid #fd7e14;
  padding: 4px 8px;
  border-radius: 4px;
  display: inline-block;
  max-width: 100%;
  color: #543005;
}

.expandable:hover {
  background: #ffe0b2;
}

.toggle {
  display: inline-block;
  width: 18px;
  text-align: center;
  font-weight: bold;
  color: #c55a11;
  margin-right: 6px;
}

.nested {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.25s ease-out, padding 0.25s ease-out, margin 0.25s ease-out;
  background: #fff9f2;
  border-left: 2px solid #ffac47;
  margin: 0;
  padding: 0;
  border-radius: 0 4px 4px 0;
}

.nested.expanded {
  max-height: 5000px; /* Large enough value for content */
  padding: 8px 12px;
  margin: 6px 0 4px 20px;
  overflow-y: auto;
  box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
}

.nested-table {
  font-size: 12px;
  margin: 4px 0;
  width: max-content; /* Shrink to content width */
  min-width: 100%;    /* But expand to fill container if content is smaller */
  table-layout: auto;
  border-collapse: collapse;
}

.nested-table th,
.nested-table td {
  padding: 5px 8px;
  border: 1px solid #eee;
  font-size: 12px;
  min-width: 90px;
  word-wrap: break-word;
  overflow-wrap: break-word;
  vertical-align: top;
  white-space: normal;
}
.nested-table tr:last-child td {
    border-bottom: 1px solid #eee; /* Ensure last row has bottom border */
}

.nested-table th {
  background: #f7f7f7;
  position: sticky;
  top: 0;
  z-index: 50;
  font-weight: 600;
  text-align: left;
}

.nested-table td.row-number {
  text-align: center;
  font-weight: normal;
  background: #fcfcfc;
  width: 40px !important;
  min-width: 40px !important;
  max-width: 40px !important;
}

/* =============================================
   Special Cell/Content Styling
   ============================================= */

.highlight {
  background: #ffc107;
  padding: 1px 3px;
  border-radius: 3px;
  font-weight: normal;
  color: #333;
}

.highlight.current {
  background: #dc3545;
  color: white;
  box-shadow: 0 0 5px rgba(220, 53, 69, 0.6);
}

.path-display {
  font-size: 10px;
  color: #6c757d;
  margin-top: 3px;
  font-style: italic;
  word-break: break-all;
  line-height: 1.3;
}

.value-special.value-null,
.value-special.value-undefined {
  color: #6c757d;
  font-style: italic;
}
.value-special .highlight {
  color: #212529; /* Ensure highlight text is visible on special values */
}

/* =============================================
   Specific Button Styles (Not in Header)
   ============================================= */

.promote-btn {
  margin-left: 8px;
  padding: 2px 6px;
  font-size: 10px;
  line-height: 1.2;
  font-weight: bold;
  cursor: pointer;
  background-color: #28a745;
  color: white;
  border: none;
  border-radius: 3px;
  vertical-align: middle;
  box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}

.promote-btn:hover {
  background-color: #218838;
  box-shadow: 0 1px 3px rgba(0,0,0,0.15);
}

/* =============================================
   Modal Internals
   ============================================= */

.modal-content {
  background: white;
  border-radius: 8px;
  padding: 25px;
  max-width: 90%;
  max-height: 90vh;
  overflow: auto;
  position: relative;
  box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  border-bottom: 1px solid #dee2e6;
  padding-bottom: 15px;
}
.modal-header h3 {
    margin: 0;
    font-size: 1.25rem;
}

.close-btn {
  background: transparent;
  color: #6c757d;
  border: none;
  font-size: 1.5rem;
  line-height: 1;
  padding: 0.25rem 0.75rem;
  cursor: pointer;
  opacity: 0.7;
}
.close-btn:hover {
    color: #343a40;
    opacity: 1;
}

/* =============================================
   Output Areas (SQL, JSON Edit)
   ============================================= */

.sql-output, .json-edit-output {
  width: 100%;
  font-family: 'Consolas', 'Menlo', 'Courier New', monospace;
  font-size: 13px;
  padding: 15px;
  border: 1px solid #ced4da;
  border-radius: 4px;
  background: #f8f9fa;
  line-height: 1.5;
}

.sql-output {
  min-height: 300px;
  resize: vertical;
}

/* =============================================
   Feedback & Utility Styles
   ============================================= */

.loading, .no-results {
  text-align: center;
  padding: 40px 20px;
  color: #6c757d;
  font-style: italic;
  font-size: 1.1em;
}

.json-edit-output.drag-over-active,
#json-modal-content.drag-over-active {
  border: 2px dashed #007bff !important;
  background-color: #e9f4ff !important;
}
#json-modal-content.drag-over-active {
    outline-offset: -10px; /* Ensure outline is visible if content padding is small */
}

/* =============================================
   Focus Styles (Accessibility)
   ============================================= */

/* General Focus Styles for Interactive Elements */
.header button:focus,
.remove-col-btn-header:focus,
.promote-btn:focus,
.close-btn:focus,
.expandable[role="button"]:focus,
th[role="button"]:focus,
.modal button:focus, /* Generic modal button focus */
.modal select:focus,
.modal textarea:focus, /* For textareas in modals like SQL, JSON */
.promote-popover-btn:focus,
.add-column-popover-btn:focus,
button:focus { /* Fallback for other buttons not specifically targeted */
  outline: 2px solid #0056b3;
  outline-offset: 2px;
  box-shadow: 0 0 0 3px rgba(0, 86, 179, 0.35);
}

/* Override for search box as it has its own distinct focus style */
.search-box:focus {
  border-color: #80bdff;
  box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
  outline: none; /* Remove default outline if box-shadow is used */
}

input[type="file"]:focus + button { /* Style for button that triggers hidden file input */
  outline: 2px solid #0056b3;
  outline-offset: 2px;
  box-shadow: 0 0 0 3px rgba(0, 86, 179, 0.35);
}

.sql-output:focus,
.json-edit-output:focus {
  border-color: #80bdff;
  box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
  outline: none;
}

/* Specific focus for popover buttons if needed for better visibility */
.promote-popover-btn:focus,
.add-column-popover-btn:focus {
  background-color: #e9ecef; /* Light background highlight */
  border-color: #0056b3; /* Add border color change */
}

.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}
</style>
  
</head>
<body>
  <div id="app">
    <div class="loading" role="status" aria-live="polite">Loading JSON data...</div>
  </div>

  <script type="module">

// --- START OF INLINED sqlGenerator.js ---
const sqlEscapeString = (str) => {
    if (str === null || str === undefined) return 'NULL';
    return str.replace(/'/g, "''");
};

const buildBaseAccessPath = (fullItemPath, rootDbColumnName, dbDialect, tableAlias = null, forFlattenInput = false) => {
    let pathPrefix = tableAlias ? `"${tableAlias}".` : '';
    let pathWithinRoot = fullItemPath.substring(rootDbColumnName.length);
    if (pathWithinRoot.startsWith('.')) {
        pathWithinRoot = pathWithinRoot.substring(1);
    }

    if (dbDialect === 'postgresql') {
        let pgPath = `${pathPrefix}"${rootDbColumnName}"`;
        // If no pathWithinRoot, it means we are accessing the rootDbColumnName itself.
        // If forFlattenInput, return as is (expecting JSONB input for functions like jsonb_array_elements,
        // actual cast to jsonb will be handled at call site if root is json).
        // If for SELECT, cast to text.
        if (!pathWithinRoot) return forFlattenInput ? pgPath : `${pgPath}::text`;

        const segments = pathWithinRoot.replace(/\[(\d+)\]/g, '.$1').split('.');
        segments.forEach((seg, idx) => {
            const isLastSegment = idx === segments.length - 1;
            // For intermediate paths or for FLATTEN input, use '->'
            // For the final segment in a SELECT, use '->>' to get text
            pgPath += (forFlattenInput || !isLastSegment) ? '->' : '->>';
            if (seg.match(/^\d+$/)) pgPath += seg; // Array index
            else pgPath += `'${sqlEscapeString(seg)}'`; // Object key
        });
        return pgPath;
    } else if (dbDialect === 'snowflake') {
        // Base access string, defaults to direct column access
        let sfAccessBase = `${pathPrefix}"${rootDbColumnName}"`;

        const needsParsing = pathWithinRoot || forFlattenInput;

        if (needsParsing) {
            sfAccessBase = `parse_json(${pathPrefix}"${rootDbColumnName}"::variant)`;
        }

        if (!pathWithinRoot) {
            return sfAccessBase;
        }

        let sfPath = sfAccessBase;
        const pathParts = pathWithinRoot.replace(/\[(\d+)\]/g, '[$1]').split('.');
        pathParts.forEach(part => {
            if (part.startsWith('[') && part.endsWith(']')) { // Array index
                sfPath += part;
            } else { // Object key
                sfPath += `:${part.replace(/:/g, "\\:")}`;
            }
        });
        return forFlattenInput ? sfPath : `${sfPath}::VARCHAR`;
    }
    // Fallback for unsupported dialect
    return `"${fullItemPath}"`;
};

const buildPathWithinElement = (elementBase, valuePathWithin, dbDialect) => {
    // elementBase is like 'f0.value' (Snowflake) or 'flat_alias.element_value' (PostgreSQL)
    // This element is already a JSON object/variant, so no initial parse_json needed here.

    if (dbDialect === 'postgresql') {
        let pgPath = elementBase; // This will be jsonb if coming from jsonb_array_elements
        if (!valuePathWithin) return `${pgPath}::text`; // Cast jsonb to text

        const segments = valuePathWithin.replace(/\[(\d+)\]/g, '.$1').split('.');
        segments.forEach((seg, idx) => {
            pgPath += (idx === segments.length - 1 ? '->>' : '->'); // -> on jsonb returns jsonb, ->> returns text
            if (seg.match(/^\d+$/)) pgPath += seg;
            else pgPath += `'${sqlEscapeString(seg)}'`;
        });
        return pgPath;
    } else if (dbDialect === 'snowflake') {
        let sfPath = elementBase; // e.g., f0.value which is a VARIANT
        if (!valuePathWithin) return `${sfPath}::VARCHAR`;

        const pathParts = valuePathWithin.replace(/\[(\d+)\]/g, '[$1]').split('.');
        pathParts.forEach(part => {
            if (part.startsWith('[') && part.endsWith(']')) {
                sfPath += part;
            } else {
                sfPath += `:${part.replace(/:/g, "\\:")}`;
            }
        });
        return `${sfPath}::VARCHAR`;
    }
    // Fallback
    return `${elementBase}${valuePathWithin ? '.' + valuePathWithin : ''}`;
};

const generateSQL = (visibleColumns, dialect = 'snowflake') => {
    try {
        const tableName = 'json_data'; // Note: Your example query uses 'cloudtrail_logs'. This might need to be configurable.
        const columns = visibleColumns;

        if (!columns || columns.length === 0) {
            return '-- No columns selected';
        }

        const mainTableAlias = "e";
        let fromParts = [`"${tableName}" AS "${mainTableAlias}"`]; // Adjust if your table name is different
        let selectExpressions = [];
        let whereConditions = [];
        let flattenCounter = 0;

        columns.forEach(col => {
            const uiColumnAlias = col.replace(/[.\[\]=:"']/g, '_');
            const rootDbColumnName = col.split(/[.\[]/)[0];
            const complexPathRegex = /^(.+?)\[([^=\]]+)="([^"]+)"\](?:\.(.+))?$/;
            const complexMatch = col.match(complexPathRegex);

            if (complexMatch) { // Path like "array_col[key="val"].field"
                const flattenAlias = `f${flattenCounter++}`;
                const fullPathToArray = complexMatch[1];
                const keyFieldInArrayElement = complexMatch[2];
                const keyValueInArrayElement = complexMatch[3].replace(/\\"/g, '"');
                const valueFieldPathWithinElement = complexMatch[4];

                const rootForArrayPath = fullPathToArray.split(/[.\[]/)[0];

                if (dialect === 'postgresql') {
                    const pgPathToArrForFlatten = buildBaseAccessPath(fullPathToArray, rootForArrayPath, 'postgresql', mainTableAlias, true);
                    // MODIFICATION: Added ::jsonb cast to the input of jsonb_array_elements
                    fromParts.push(`, LATERAL jsonb_array_elements((${pgPathToArrForFlatten})::jsonb) AS ${flattenAlias}(element_value)`);
                    
                    const selectPath = buildPathWithinElement(`${flattenAlias}.element_value`, valueFieldPathWithinElement, 'postgresql');
                    selectExpressions.push(`${selectPath} AS "${uiColumnAlias}"`);
                    
                    // element_value is jsonb, ->> extracts text for comparison
                    whereConditions.push(`${flattenAlias}.element_value->>'${sqlEscapeString(keyFieldInArrayElement)}' = '${sqlEscapeString(keyValueInArrayElement)}'`);
                } else if (dialect === 'snowflake') {
                    const sfPathToArrForFlatten = buildBaseAccessPath(fullPathToArray, rootForArrayPath, 'snowflake', mainTableAlias, true);
                    fromParts.push(`, LATERAL FLATTEN(input => ${sfPathToArrForFlatten}) AS ${flattenAlias}`);

                    const selectPath = buildPathWithinElement(`${flattenAlias}.value`, valueFieldPathWithinElement, 'snowflake');
                    selectExpressions.push(`${selectPath} AS "${uiColumnAlias}"`);
                    
                    let keyAccessPath = `${flattenAlias}.value`; 
                    const keyFieldParts = keyFieldInArrayElement.replace(/\[(\d+)\]/g, '[$1]').split('.');
                     keyFieldParts.forEach(part => {
                        if (part.startsWith('[') && part.endsWith(']')) keyAccessPath += part;
                        else keyAccessPath += `:${part.replace(/:/g, "\\:")}`;
                    });
                    whereConditions.push(`${keyAccessPath}::VARCHAR = '${sqlEscapeString(keyValueInArrayElement)}'`);
                }
            } else { // Simple path like "id" or "user.name"
                selectExpressions.push(`${buildBaseAccessPath(col, rootDbColumnName, dialect, mainTableAlias, false)} AS "${uiColumnAlias}"`);
            }
        });
        
        let sql = `SELECT\n  ${selectExpressions.join(',\n  ')}\nFROM ${fromParts.join('\n  ')}`;
        if (whereConditions.length > 0) {
            sql += `\nWHERE ${whereConditions.join('\n  AND ')};`;
        } else {
            sql += ';';
        }

        return sql;

    } catch (e) {
        console.error("Error generating SQL:", e);
        return `-- Error generating SQL: ${e.message}\n-- Stack: ${e.stack ? e.stack.split('\n').map(s => `-- ${s}`).join('\n') : ''}`;
    }
};
// --- END OF INLINED sqlGenerator.js ---

// --- START OF INLINED state.js ---
// state.js

// Reactive state management
const createReactiveState = (initial) => {
    const listeners = new Set();
    const state = new Proxy(initial, {
      set(target, key, value) {
        const oldValue = target[key];
        if (oldValue !== value) {
          if ((key === 'expandedPaths' || key === 'allPossibleColumns') && value instanceof Set && oldValue instanceof Set) { // Updated for allPossibleColumns
             if (value.size !== oldValue.size || ![...value].every(item => oldValue.has(item))) {
                target[key] = value;
                listeners.forEach(fn => fn(key, value));
             }
          } else if (key === 'visibleColumns' && Array.isArray(value) && Array.isArray(oldValue)) {
              if (value.length !== oldValue.length || value.some((item, i) => item !== oldValue[i])) {
                  target[key] = value;
                  listeners.forEach(fn => fn(key, value));
              }
          }
          else {
            target[key] = value;
            listeners.forEach(fn => fn(key, value));
          }
        }
        return true;
      }
    });
    
    state.subscribe = (fn) => {
      listeners.add(fn);
      return () => listeners.delete(fn);
    };
    
    state.notify = (changedKey = null) => { 
      listeners.forEach(fn => fn(changedKey));
    };
    
    return state;
  };
  
  // Application state
 const state = createReactiveState({
    data: [],
    searchQuery: '',
    expandedPaths: new Set(),
    visibleColumns: [],
    sortBy: null,
    sortDirection: 'asc',
    showPaths: false,
    searchResults: [],
    currentSearchIndex: -1,
    showSqlModal: false,
    sqlDialect: 'snowflake', // Default to Snowflake
    editModeActive: false,
    showJsonModal: false,       // Controls visibility of the JSON edit modal
    rawJsonEditContent: '',   // Holds the string content of the JSON editor
    jsonValidationMessage: '', // Message for JSON validation status
    showPromoteKeyPopover: false, 
    promoteKeyPopoverContext: null, 
    allPossibleColumns: new Set(),    // NEW: Stores all discovered column paths
    showAddColumnPopover: false,      // NEW: Controls visibility of "Add Column" popover
    addColumnPopoverAnchor: null,     // NEW: Anchor element for "Add Column" popover
    showCsvModal: false,          // Controls visibility of the CSV export modal
    csvOutputContent: '',       // Holds the generated CSV string
    darkModeActive: false, // Add this
  });

// --- END OF INLINED state.js ---

// --- START OF INLINED utils.js ---

const escapeStringForDataAttribute = (str) => {
  if (typeof str !== 'string') return str;
  return str.replace(/&/g, '&') // Escape ampersands first
            .replace(/"/g, '"'); // Escape double quotes
};

const flatten = (obj, prefix = '', result = []) => {
  if (!obj || typeof obj !== 'object') {
    if (prefix) result.push({ path: prefix, value: obj });
    return result;
  }
  
  if (Array.isArray(obj)) {
    obj.forEach((item, index) => {
      const arrayPath = prefix ? `${prefix}[${index}]` : `[${index}]`;
      if (item && typeof item === 'object') {
        flatten(item, arrayPath, result);
      } else {
        result.push({ path: arrayPath, value: item });
      }
    });
  } else {
    Object.entries(obj).forEach(([key, value]) => {
      const path = prefix ? `${prefix}.${key}` : key;
      if (value && typeof value === 'object') {
        flatten(value, path, result);
      } else {
        result.push({ path, value });
      }
    });
  }
  
  return result;
};

const getAllObjectPaths = (obj, currentPath = '', allPaths = []) => {
  if (obj && typeof obj === 'object') {
      if (currentPath) {
          allPaths.push(currentPath);
      }

      if (Array.isArray(obj)) {
          obj.forEach((item, index) => {
              const newPath = currentPath ? `${currentPath}[${index}]` : `[${index}]`;
              getAllObjectPaths(item, newPath, allPaths);
          });
      } else {
          for (const key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) {
                  const newPath = currentPath ? `${currentPath}.${key}` : key;
                  getAllObjectPaths(obj[key], newPath, allPaths);
              }
          }
      }
  }
  return allPaths;
};

const getValue = (obj, path) => {
  if (!obj || !path) return undefined;
  
  try {
      if (!path.includes('.') && !path.includes('[')) {
          return obj[path];
      }

      let processedPath = path.replace(/\[(\d+)\]/g, '.$1'); 
      const pathSegments = processedPath.split('.');
      
      let current = obj;
      const arraySelectorRegex = /^(\w+)\[(.+?)="([^"]*)"\]$/; 

      for (const segment of pathSegments) {
          if (current == null) return undefined;

          const selectorMatch = segment.match(arraySelectorRegex);
          
          if (selectorMatch) {
              const arrayNameInSegment = selectorMatch[1];
              const keyField = selectorMatch[2]; 
              const keyValue = selectorMatch[3].replace(/\\"/g, '"'); 
              
              const arrayItself = current[arrayNameInSegment];
              if (!Array.isArray(arrayItself)) return undefined; 
              
              const foundItem = arrayItself.find(item => item && typeof item === 'object' && String(item[keyField]) === keyValue);
              if (!foundItem) return undefined; 
              current = foundItem; 
          } else {
              current = current[segment];
          }
      }
      return current;
  } catch (e) {
      return undefined;
  }
};

const highlightText = (text, query, isActive = false) => {
  if (text === null || text === undefined) text = '';
  if (!query) return String(text);
  const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const regex = new RegExp(`(${escapedQuery})`, 'gi');
  return String(text).replace(regex, `<span class="highlight ${isActive ? 'current' : ''}">$1</span>`);
};

const performSearch = (data, query) => {
    if (!query || String(query).trim() === '') return [];
    const results = [];
    const queryLower = String(query).toLowerCase();

    data.forEach((row, rowIndex) => {
        function searchItem(item, currentPath) {
            if (item === null || item === undefined) {
                return;
            }

            if (typeof item === 'object' && !Array.isArray(item)) {
                for (const key in item) {
                    if (Object.prototype.hasOwnProperty.call(item, key)) {
                        const valuePath = currentPath ? `${currentPath}.${key}` : key;
                        // Search Key
                        if (key.toLowerCase().includes(queryLower)) {
                            results.push({
                                rowIndex,
                                path: valuePath, // Path to the value of the matched key
                                value: item[key], // Actual value of the key
                                matchedPart: 'key',
                                matchedKeyName: key // The key string that matched
                            });
                        }
                        // Recurse for value associated with this key
                        searchItem(item[key], valuePath);
                    }
                }
            } else if (Array.isArray(item)) {
                item.forEach((element, index) => {
                    const elementPath = `${currentPath}[${index}]`;
                    searchItem(element, elementPath);
                });
            } else {
                // Search Value (primitive)
                if (String(item).toLowerCase().includes(queryLower)) {
                    results.push({
                        rowIndex,
                        path: currentPath, // Path to this primitive value
                        value: item, // Original primitive value
                        matchedPart: 'value'
                    });
                }
            }
        }
        searchItem(row, ''); // Start search for the current row object
    });

    // Deduplicate results:
    // If a key match and a value match occur for the exact same path,
    // prioritize the key match. This is because a key match is often more specific.
    const uniqueResultsMap = new Map();
    for (const res of results) {
        const resultKey = `${res.rowIndex}-${res.path}`;
        const existing = uniqueResultsMap.get(resultKey);
        if (!existing) {
            uniqueResultsMap.set(resultKey, res);
        } else {
            // If existing is a value match and new one is a key match for the same path, prefer key match.
            if (existing.matchedPart === 'value' && res.matchedPart === 'key') {
                uniqueResultsMap.set(resultKey, res);
            }
            // Otherwise (existing is key, new is value; or both are same type), keep the existing (first one found).
        }
    }
    return Array.from(uniqueResultsMap.values());
};


const escapeCsvField = (field) => {
  if (field === null || field === undefined) {
      return '';
  }
  const stringField = String(field);
  if (stringField.includes(',') || stringField.includes('\n') || stringField.includes('"')) {
      return `"${stringField.replace(/"/g, '""')}"`;
  }
  return stringField;
};

const processCellValueForRecord = (valueString) => {
  const trimmedValue = typeof valueString === 'string' ? valueString.trim() : valueString;
  if (typeof trimmedValue === 'string' &&
      ((trimmedValue.startsWith('{') && trimmedValue.endsWith('}')) ||
       (trimmedValue.startsWith('[') && trimmedValue.endsWith(']')))) {
      try {
          return JSON.parse(trimmedValue);
      } catch (e) {
          // If parsing fails, it's either not JSON or malformed JSON.
          // Return the original string as is.
          return valueString; 
      }
  }
  return valueString;
};

const robustParseCSV = (csvString, delimiter = '\t') => {
  const objects = [];
  let headers = [];
  
  let currentRow = [];
  let currentField = "";
  let inQuotedField = false;
  let i = 0;

  csvString = csvString.replace(/\r\n?/g, '\n').trim();

  if (csvString === "") {
      robustParseCSV.lastHeaders = [];
      return [];
  }

  while (i < csvString.length) {
      const char = csvString[i];

      if (inQuotedField) {
          if (char === '"') {
              // Check for escaped quote (RFC 4180 compliant: "")
              if (i + 1 < csvString.length && csvString[i + 1] === '"') {
                  currentField += '"'; // Add one quote to the field
                  i++; // And skip the second quote of the pair
              }
              // Lenient check: Is this quote a field terminator?
              // A quote terminates a field if it's the last char, or followed by a delimiter or newline.
              else if (
                  (i + 1 === csvString.length) || // End of the entire string
                  (i + 1 < csvString.length && (csvString[i + 1] === delimiter || csvString[i + 1] === '\n'))
              ) {
                  inQuotedField = false; // End of quoted field. The quote itself is not part of the data.
              }
              // Lenient part: If it's a quote, but not an RFC-escaped one, and not a field terminator
              // (e.g., a quote inside a JSON string that wasn't CSV-escaped), treat it as literal data.
              else {
                  currentField += char; // Add the quote as data
              }
          } else {
              currentField += char; // Append other characters (including newline) to current field
          }
      } else { // Not in a quoted field
          if (char === '"') {
              // If we are not in a quoted field and we see a quote:
              // If currentField is empty, it's the start of a new quoted field.
              if (currentField.length === 0) {
                  inQuotedField = true;
                  // The quote itself is not added to currentField here; it's a wrapper.
              } else {
                  // A quote appears in an unquoted field, not at the start. Treat as literal.
                  currentField += char;
              }
          } else if (char === delimiter) {
              currentRow.push(currentField);
              currentField = "";
          } else if (char === '\n') {
                            // Heuristic for unquoted newlines within fields:
              // If headers are parsed, and we haven't collected all expected fields for the current row yet
              // (i.e., number of fields in currentRow is less than total headers - 1),
              // and the current field has content, assume this newline is part of the current field.
              // This handles unquoted newlines in fields that are not the last field of a record,
              // assuming records are not sparse (i.e., all delimiters are present).
              if (headers.length > 0 && 
                  currentRow.length < headers.length - 1 &&  // We expect more delimiters on this logical line
                  currentField.length > 0                   // Current field is not empty
                 ) {
                  currentField += char; // Append newline to currentField and continue to next char
              } else {
                  // Original logic: Treat newline as a row delimiter
                  currentRow.push(currentField);
                  currentField = "";

                  if (headers.length === 0) {
                      // First row, assume it's headers
                      headers = currentRow.map(h => h.trim());
                  } else {
                      // Data row
                      // Ensure record creation only if row has some substance
                      if (currentRow.some(val => val !== undefined && (typeof val === 'string' ? val.trim() !== '' : true))) {
                          const record = {};
                          headers.forEach((header, index) => {
                              const H = header || `_col_${index+1}`; // Use header or generate one if empty
                              const rawValue = currentRow[index] !== undefined ? currentRow[index] : "";
                              record[H] = processCellValueForRecord(rawValue);
                          });
                          objects.push(record);
                      }
                  }
                  currentRow = []; // Reset for next row
              }
          } else {
              currentField += char;
          }
      }
      i++;
  }

  currentRow.push(currentField); 

  if (currentRow.length > 0) {
      if (headers.length === 0) { 
          headers = currentRow.map(h => h.trim());
          // If headers were derived from the only line, and it wasn't an empty line,
          // there are no data objects to create.
          if (objects.length === 0 && !currentRow.every(f => f === "")) {
              // Do not create an empty object if this was the header line.
          }
      } else {
          if (currentRow.some(val => val !== undefined && (typeof val === 'string' ? val.trim() !== '' : true))) {
              const record = {};
              headers.forEach((header, index) => {
                  const H = header || `_col_${index+1}`;
                  const rawValue = currentRow[index] !== undefined ? currentRow[index] : "";
                  record[H] = processCellValueForRecord(rawValue);
              });
              objects.push(record);
          }
      }
  }
  
  if (headers.length > 0 && headers.every(h => h === '')) {
      console.warn("CSV Warning: All parsed headers are empty. CSV might be malformed or start with an empty line treated as headers.");
      headers = []; 
  }

  robustParseCSV.lastHeaders = headers.filter(h => h !== ''); 
  return objects;
};
robustParseCSV.lastHeaders = []; 

const detectDelimiter = (textSample) => {
  if (!textSample || textSample.trim() === '') return ','; 
  const firstLineBreak = textSample.indexOf('\n');
  const firstLine = firstLineBreak === -1 ? textSample.trim() : textSample.substring(0, firstLineBreak).trim();

  if (firstLine.length === 0) return ','; 

  const delimiters = [
      { char: ',', count: (firstLine.match(/,/g) || []).length },
      { char: '\t', count: (firstLine.match(/\t/g) || []).length },
      { char: '|', count: (firstLine.match(/\|/g) || []).length },
  ];

  const presentDelimiters = delimiters.filter(d => d.count > 0);

  if (presentDelimiters.length === 0) {
      // If no common delimiters found, check if it might be single-column data
      // (e.g., a list of JSON objects, each on a new line, without typical CSV delimiters)
      // In such cases, any delimiter would work, but ',' is a common default.
      return ',';
  }

  presentDelimiters.sort((a, b) => b.count - a.count);
  return presentDelimiters[0].char;
};

function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
            func.apply(this, args);
        }, delay);
    };
}


// --- END OF INLINED utils.js ---

// --- START OF INLINED ui.js ---
// Focus Management
let previouslyFocusedElement = null;

function openModalFocus(modalElementQuerySelector) {
    previouslyFocusedElement = document.activeElement;
    requestAnimationFrame(() => {
        const modal = document.querySelector(modalElementQuerySelector);
        if (modal) {
            const firstFocusableElement = modal.querySelector(
                'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            if (firstFocusableElement) {
                firstFocusableElement.focus();
            }
            modal.addEventListener('keydown', trapFocusInModal);
        }
    });
}

function closeModalFocus(modalElementQuerySelector) {
    const modal = document.querySelector(modalElementQuerySelector);
    if (modal) {
        modal.removeEventListener('keydown', trapFocusInModal);
    }
    if (previouslyFocusedElement) {
        if (document.body.contains(previouslyFocusedElement) && typeof previouslyFocusedElement.focus === 'function') {
           previouslyFocusedElement.focus();
        }
        previouslyFocusedElement = null;
    }
}

function trapFocusInModal(e) {
    if (e.key !== 'Tab') return;
    const modal = e.currentTarget;
    const focusableElements = Array.from(
        modal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])')
    ).filter(el => el.offsetParent !== null && !el.disabled && el.offsetWidth > 0 && el.offsetHeight > 0); // Added visibility check
    if (focusableElements.length === 0) return;
    const firstFocusableElement = focusableElements[0];
    const lastFocusableElement = focusableElements[focusableElements.length - 1];
    if (e.shiftKey) {
        if (document.activeElement === firstFocusableElement) {
            lastFocusableElement.focus();
            e.preventDefault();
        }
    } else {
        if (document.activeElement === lastFocusableElement) {
            firstFocusableElement.focus();
            e.preventDefault();
        }
    }
}

const scrollToCurrentSearchResult = () => {
  const currentResultElement = document.querySelector('.highlight.current');
  if (currentResultElement) {
    const rect = currentResultElement.getBoundingClientRect();
    if (rect.width > 0 && rect.height > 0) { 
        currentResultElement.scrollIntoView({
          behavior: 'smooth', 
          block: 'center', 
          inline: 'nearest' 
        });
    }
  }
};

const expandToResult = (result) => {
  try {
    const pathParts = result.path.replace(/\[(\d+)\]/g, '.$1').split('.');
    let currentPath = '';
    let needsExpandedPathNotify = false;
    
    pathParts.forEach((part, index) => {
      currentPath = index === 0 ? part : `${currentPath}.${part}`;
      const objectPathForExpansion = currentPath.replace(/\.(\d+)(?=\.|$)/g, '[$1]');
      const valueAtPath = getValue(state.data[result.rowIndex], objectPathForExpansion);
      if (index < pathParts.length - 1 && valueAtPath && typeof valueAtPath === 'object') {
        if (!state.expandedPaths.has(`${result.rowIndex}-${objectPathForExpansion}`)) {
            state.expandedPaths.add(`${result.rowIndex}-${objectPathForExpansion}`);
            needsExpandedPathNotify = true;
        }
      }
    });
    
    const finalValue = getValue(state.data[result.rowIndex], result.path);
     if (finalValue && typeof finalValue === 'object' && !state.expandedPaths.has(`${result.rowIndex}-${result.path}`)) {
         state.expandedPaths.add(`${result.rowIndex}-${result.path}`);
         needsExpandedPathNotify = true;
     }


    if (needsExpandedPathNotify) {
        state.notify('expandedPaths'); 
    }
    
    requestAnimationFrame(scrollToCurrentSearchResult);

  } catch (e) {
    console.warn('Error expanding to result:', e);
  }
};

const updateAllPossibleColumns = () => {
  const newAllPossible = new Set();
  state.data.forEach(row => {
      if (row && typeof row === 'object' && row !== null) {
          Object.keys(row).forEach(key => newAllPossible.add(key));
      }
  });
  state.visibleColumns.forEach(colPath => newAllPossible.add(colPath));
  state.allPossibleColumns.forEach(colPath => newAllPossible.add(colPath));

  if (newAllPossible.size !== state.allPossibleColumns.size || ![...newAllPossible].every(item => state.allPossibleColumns.has(item))) {
      state.allPossibleColumns = newAllPossible;
  }
};

const generateCSV = () => {
  if (!state.data || state.data.length === 0) {
      return 'No data to export.';
  }
  if (!state.visibleColumns || state.visibleColumns.length === 0) {
      return 'No columns currently visible for export.';
  }
  const headers = state.visibleColumns.map(header => escapeCsvField(header));
  const rows = state.data.map(row => {
      return state.visibleColumns.map(colKey => {
          const value = getValue(row, colKey);
          let cellValue;
          if (value === null || value === undefined) {
              cellValue = '';
          } else if (typeof value === 'object') {
              const stringified = JSON.stringify(value);
              const previewLength = 15;
              const preview = stringified.substring(0, previewLength);
              const prefix = Array.isArray(value) ? "<Json Array> " : "<Json Object> ";
              cellValue = prefix + preview + (stringified.length > previewLength ? "..." : "");
          } else {
              cellValue = String(value);
          }
          return escapeCsvField(cellValue);
      }).join(',');
  });
  return [headers.join(','), ...rows].join('\n');
};

const renderCsvModal = () => {
  if (!state.showCsvModal) return '';
  return `
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="csv-modal-title">
      <div id="csv-modal-content-wrapper" class="modal-content" style="width: 900px; display: flex; flex-direction: column; max-height: 80vh;">
        <div class="modal-header">
          <h3 id="csv-modal-title">CSV Export</h3>
          <div>
            <button data-action="copy-csv" style="margin-right: 10px;">Copy CSV</button>
            <button data-action="download-csv" style="margin-right: 10px;">Download CSV</button>
            <button class="close-btn" data-action="close-csv" aria-label="Close CSV modal">×</button>
          </div>
        </div>
        <textarea id="csv-output-area" class="sql-output" readonly style="flex-grow: 1; width: 100%; resize: none; margin-top: 10px;">${escapeStringForDataAttribute(state.csvOutputContent)}</textarea>
        <div style="font-size: 12px; color: #666; margin-top: 5px;">Exports currently visible top-level columns. Nested objects/arrays are summarized.</div>
      </div>
    </div>
  `;
};
  
const renderHeader = () => {
  const hiddenCount = state.searchResults.filter(result => {
      const rootColumn = result.path.split(/[.\[]/)[0];
      return !state.visibleColumns.includes(rootColumn) && !state.visibleColumns.includes(result.path);
    }
  ).length;

  let searchInfoText;
  if (state.searchResults.length > 0) {
    searchInfoText = `${state.currentSearchIndex + 1} of ${state.searchResults.length}${hiddenCount > 0 ? ` (${hiddenCount} hidden)` : ''}`;
  } else if (state.searchQuery && state.searchResults.length === 0) {
    searchInfoText = 'No matches';
  } else {
    searchInfoText = `${state.data.length} rows`;
  }

  return `
    <div class="header">
    
      <div class="search-group">
        <input 
          aria-label="Search JSON content"
          id="json-browser-search-box" 
          type="text" 
          class="search-box" 
          placeholder="Search JSON (Press Enter)" 
          value="${escapeStringForDataAttribute(state.searchQuery)}"
          data-action="search" 
        >
        <button class="search-button" data-action="execute-search" aria-label="Execute search">Search</button>
        <div class="search-nav">
          <button aria-label="Previous search result" data-action="search-prev" ${state.searchResults.length === 0 ? 'disabled' : ''}>←</button>
          <button aria-label="Next search result" data-action="search-next" ${state.searchResults.length === 0 ? 'disabled' : ''}>→</button>
        </div>
        <div class="search-info" role="status" aria-live="polite" aria-atomic="true">
          ${searchInfoText}
        </div>
      </div>

      <div class="view-controls-group">
        <button data-action="reset-view" title="Reset view to default columns and expansion state">Reset View</button>
        <button data-action="expand-all" title="Expand all expandable items">Expand All</button>
        <button data-action="collapse-all" title="Collapse all expanded items">Collapse All</button>
        <button data-action="toggle-paths" class="${state.showPaths ? 'active' : ''}" title="Toggle visibility of JSON paths">
          Paths
        </button>
      </div>

      <div class="function-controls-group">
        <button data-action="toggle-edit-mode" class="edit-mode-btn ${state.editModeActive ? 'active' : ''}" title="Toggle column editing, reordering, and value promotion">
          ${state.editModeActive ? 'Edit Mode' : 'Edit Mode'}
        </button>
        <button 
            id="add-column-button" 
            class="add-column-btn ${state.editModeActive ? 'visible' : 'hidden-button'}" 
            data-action="show-add-column-popover" 
            aria-haspopup="true" 
            aria-expanded="${state.showAddColumnPopover}" 
            title="Add a previously removed column"
            ${!state.editModeActive ? 'tabindex="-1"' : ''} 
        >
            Add Column +
        </button>
        <button data-action="show-sql" title="Generate SQL (CREATE TABLE and INSERT statements) from current view">SQL</button>
        <button data-action="show-json" title="View or edit the raw JSON/CSV/TSV data">View/Edit Data</button>
        <button data-action="show-csv" title="Export current table view as CSV">Export CSV</button>
      </div>
    </div>
  `;
};

const renderCell = (value, path, rowIndex, isNestedCall = false) => {
  const isExpandable = value && typeof value === 'object';
  const expandKey = `${rowIndex}-${path}`;
  const isExpanded = state.expandedPaths.has(expandKey);
  const isTopLevelCell = !isNestedCall;

  let cellDisplayHtml = '';
  const currentResult = state.searchResults[state.currentSearchIndex];
  
  let isCurrentValueHighlight = false;
  if (currentResult && currentResult.rowIndex === rowIndex && currentResult.path === path) {
      if (currentResult.matchedPart === 'value') {
          isCurrentValueHighlight = true;
      } else if (currentResult.matchedPart === 'key' && isExpandable && !isExpanded) {
          isCurrentValueHighlight = true;
      }
  }

  if (isExpandable) {
      const displayValueText = Array.isArray(value) 
          ? `Array(${value.length})` 
          : `Object(${Object.keys(value).length})`;
      const highlightedDisplayValue = highlightText(displayValueText, state.searchQuery, isCurrentValueHighlight);
      
      const nestedContentId = `nested-content-${rowIndex}-${path.replace(/[^a-zA-Z0-9_-]/g, '_')}`;
      const nestedDivContent = isExpanded ? renderNestedObject(value, path, rowIndex) : '';
      
      cellDisplayHtml = `
        <div 
          class="expandable" 
          data-action="toggle" 
          data-path="${escapeStringForDataAttribute(path)}" 
          data-row="${rowIndex}"
          role="button"
          tabindex="0"
          aria-expanded="${isExpanded ? 'true' : 'false'}"
          aria-controls="${nestedContentId}">
          <span class="toggle" aria-hidden="true">${isExpanded ? '−' : '+'}</span>
          ${highlightedDisplayValue}
        </div>
        <div class="nested ${isExpanded ? 'expanded' : ''}" id="${nestedContentId}" data-parent-path="${escapeStringForDataAttribute(path)}" data-row-index-for-nested="${rowIndex}">
          ${nestedDivContent}
        </div>
      `;
  } else {
      let textForHighlighting;
      let finalDisplay;

      if (value === null) textForHighlighting = '<null>';
      else if (value === undefined) textForHighlighting = '<undefined>';
      else textForHighlighting = String(value);
      
      let actualHighlightStateForPrimitive = isCurrentValueHighlight;
      if(currentResult && currentResult.rowIndex === rowIndex && currentResult.path === path && currentResult.matchedPart === 'key'){
        actualHighlightStateForPrimitive = false;
      }

      finalDisplay = highlightText(textForHighlighting, state.searchQuery, actualHighlightStateForPrimitive);

      if (value === null) finalDisplay = `<span class="value-special value-null">${finalDisplay}</span>`;
      else if (value === undefined) finalDisplay = `<span class="value-special value-undefined">${finalDisplay}</span>`;
      
      cellDisplayHtml = finalDisplay;

      const isPrimitive = value !== null && value !== undefined && typeof value !== 'object';
      if (state.editModeActive && isPrimitive && isNestedCall) { 
          cellDisplayHtml += `
            <button 
              class="promote-btn" 
              data-action="promote-value" 
              data-path-to-value="${escapeStringForDataAttribute(path)}" 
              data-row-index="${rowIndex}"
              aria-label="Promote '${escapeStringForDataAttribute(path)}' to column"
              title="Promote '${escapeStringForDataAttribute(path)}' to column"
            >+</button>`;
      }
  }
  
  const pathDisplay = state.showPaths ? `<div class="path-display">${path}</div>` : '';
  
  if (isTopLevelCell) {
      return `<td class="${path === 'id' ? 'col-id' : ''}"><div>${cellDisplayHtml}</div>${pathDisplay}</td>`;
  } else {
      return `<div>${cellDisplayHtml}</div>`;
  }
};

const renderNestedObject = (obj, basePath, rowIndex) => {
  if (!obj || typeof obj !== 'object') {
    const currentResult = state.searchResults[state.currentSearchIndex];
    let isCurrentMatch = false;
    if (currentResult && currentResult.rowIndex === rowIndex && currentResult.path === basePath && currentResult.matchedPart === 'value') {
        isCurrentMatch = true;
    }
    
    let promoteButtonHtml = '';
    const isPrimitive = obj !== null && obj !== undefined && typeof obj !== 'object';
    if (state.editModeActive && isPrimitive) { 
      promoteButtonHtml = `
        <button 
          class="promote-btn" 
          data-action="promote-value" 
          data-path-to-value="${escapeStringForDataAttribute(basePath)}" 
          data-row-index="${rowIndex}"
          aria-label="Promote '${escapeStringForDataAttribute(basePath)}' to column"
          title="Promote '${escapeStringForDataAttribute(basePath)}' to column"
        >+</button>`;
    }
    return `<div>${highlightText(String(obj || ''), state.searchQuery, isCurrentMatch)}${promoteButtonHtml}</div>`;
  }
  
  let rows = '';
  let tableHtml = '';

  if (Array.isArray(obj)) {
    if (obj.length === 0) {
      return '<div><i>(empty array)</i></div>';
    }
    const firstItem = obj[0];
    let isArrayOfObjects = typeof firstItem === 'object' && firstItem !== null && !Array.isArray(firstItem);
    if (isArrayOfObjects) {
      const columnKeys = new Set();
      const sampleSize = Math.min(obj.length, 10); 
      for (let i = 0; i < sampleSize; i++) {
          if (typeof obj[i] === 'object' && obj[i] !== null && !Array.isArray(obj[i])) {
              Object.keys(obj[i]).forEach(key => columnKeys.add(key));
          } else { 
              isArrayOfObjects = false;
              break;
          }
      }
      if(sampleSize === 0) isArrayOfObjects = false; 

      if (columnKeys.size === 0 && isArrayOfObjects) { 
           if (obj.every(item => typeof item === 'object' && item !== null && !Array.isArray(item) && Object.keys(item).length === 0)) {
           } else { 
              isArrayOfObjects = false;
           }
      }

      if (isArrayOfObjects) { 
          const headers = Array.from(columnKeys).sort(); 
          let headerRow = '<tr>'; 
          headers.forEach(header => {
              headerRow += `<th>${highlightText(header, state.searchQuery, false)}</th>`;
          });
          headerRow += '</tr>';
          let bodyRows = obj.map((item, index) => {
              const itemBasePath = `${basePath}[${index}]`;
              let rowCells = ``; 
              if (typeof item === 'object' && item !== null && !Array.isArray(item)) { 
                  headers.forEach(key => {
                      const cellPath = `${itemBasePath}.${key}`;
                      const cellContent = renderCell(item[key], cellPath, rowIndex, true); 
                      const pathDisplay = state.showPaths ? `<div class="path-display">${cellPath}</div>` : '';
                      rowCells += `<td>${cellContent}${pathDisplay}</td>`;
                  });
              } else { 
                  const cellContent = renderCell(item, itemBasePath, rowIndex, true);
                  const pathDisplay = state.showPaths ? `<div class="path-display">${itemBasePath}</div>` : '';
                  rowCells += `<td colspan="${headers.length}">${cellContent}${pathDisplay}</td>`;
              }
              return `<tr>${rowCells}</tr>`;
          }).join('');
          tableHtml = `<table class="nested-table"><thead>${headerRow}</thead><tbody>${bodyRows}</tbody></table>`;
      }
    } 
    if (!isArrayOfObjects) { 
      rows = obj.map((item, index) => {
        const itemPath = `${basePath}[${index}]`;
        const itemContent = renderCell(item, itemPath, rowIndex, true); 
        const pathDisplay = state.showPaths ? `<div class="path-display">${itemPath}</div>` : '';
        return `
          <tr>
            <td class="row-number">[${index}]</td>
            <td>${itemContent}${pathDisplay}</td> 
          </tr>
        `;
      }).join('');
      tableHtml = `<table class="nested-table"><tbody>${rows}</tbody></table>`;
    }
  } else {  
      rows = Object.entries(obj).map(([key, value]) => {
        const itemPath = `${basePath}.${key}`;
        const valueContent = renderCell(value, itemPath, rowIndex, true); 
        const pathDisplay = state.showPaths ? `<div class="path-display">${itemPath}</div>` : '';
        
        const currentResult = state.searchResults[state.currentSearchIndex];
        let isCurrentKeyHighlight = false;
        if (currentResult &&
            currentResult.rowIndex === rowIndex &&
            currentResult.path === itemPath && 
            currentResult.matchedPart === 'key' &&
            currentResult.matchedKeyName && 
            currentResult.matchedKeyName.toLowerCase() === key.toLowerCase()
           ) {
            isCurrentKeyHighlight = true;
        }

      return `
          <tr>
            <td><div><strong>${highlightText(key, state.searchQuery, isCurrentKeyHighlight)}</strong></div></td>
            <td>${valueContent}${pathDisplay}</td>
          </tr>
      `;
      }).join('');
      tableHtml = `<table class="nested-table"><tbody>${rows}</tbody></table>`;
  }
  return tableHtml;
};

const renderTable = () => {
  if (state.data.length === 0 && !state.showJsonModal) {
    return '<div class="no-results" role="status" aria-live="polite">No data available. Click "View/Edit Data" to load or paste data.</div>';
  }
  if (state.data.length === 0 && state.showJsonModal) {
      return '';
  }

  const sortedData = [...state.data];
  if (state.sortBy) {
    sortedData.sort((a, b) => {
      const aVal = getValue(a, state.sortBy);
      const bVal = getValue(b, state.sortBy);
      let comparison = 0;
      if (typeof aVal === 'number' && typeof bVal === 'number') {
          comparison = aVal - bVal;
      } else if (typeof aVal === 'string' && typeof bVal === 'string') {
          comparison = aVal.localeCompare(bVal);
      } else {
          comparison = String(aVal).localeCompare(String(bVal));
      }
      return state.sortDirection === 'asc' ? comparison : -comparison;
    });
  }

  return `
    <div class="json-table">
      <table>
        <thead>
          <tr>
            <th class="row-number"><div>#</div></th>
            ${state.visibleColumns.map(col => {
              let removeButtonHtml = '';
              const draggableAttribute = state.editModeActive ? 'draggable="true"' : '';
              const thStyles = state.editModeActive ? 'cursor: grab;' : '';
              if (state.editModeActive) {
                  removeButtonHtml = `
                    <button 
                        class="remove-col-btn-header" 
                        data-action="remove-column-header" 
                        data-column="${encodeURIComponent(col)}"
                        aria-label="Remove column '${escapeStringForDataAttribute(col)}'" 
                        title="Remove column '${escapeStringForDataAttribute(col)}'" 
                    >−</button>`;
              }

              const currentSearchItem = state.searchResults[state.currentSearchIndex];
              let isHeaderCurrentlyMatched = false;
              if (currentSearchItem &&
                  currentSearchItem.matchedPart === 'key' &&
                  currentSearchItem.path === col && 
                  state.searchQuery && 
                  (currentSearchItem.matchedKeyName || col).toLowerCase().includes(state.searchQuery.toLowerCase())) {
                  isHeaderCurrentlyMatched = true;
              }

              return `
              <th 
                role="button"
                tabindex="0"
                data-action="sort" 
                data-column="${encodeURIComponent(col)}" 
                class="${state.sortBy === col ? `sorted ${state.sortDirection}` : ''} ${col.toLowerCase() === 'id' ? 'col-id' : ''}"
                ${draggableAttribute}
                style="${thStyles}"
                aria-sort="${state.sortBy === col ? (state.sortDirection === 'asc' ? 'ascending' : 'descending') : 'none'}"
              >
                <div>
                  ${highlightText(col, state.searchQuery, isHeaderCurrentlyMatched)}
                  ${removeButtonHtml}
                </div>
                ${state.showPaths ? `<div class="path-display">${col}</div>` : ''}
              </th>
            `}).join('')}
          </tr>
        </thead>
        <tbody>
          ${sortedData.map((row, index) => {
            const originalRowIndex = state.data.indexOf(row); 
            return `
            <tr>
              <td class="row-number"><div>${index + 1}</div></td>
              ${state.visibleColumns.map(col => 
                renderCell(getValue(row, col), col, originalRowIndex, false) 
              ).join('')}
            </tr>
          `}).join('')}
        </tbody>
      </table>
    </div>
  `;
};
  
const renderSqlModal = () => {
  if (!state.showSqlModal) return '';
  return `
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="sql-modal-title" id="sql-modal-dialog">
      <div id="sql-modal-content-wrapper" class="modal-content" style="width: 900px;">
        <div class="modal-header">
          <h3 id="sql-modal-title">Generated SQL</h3>
          <div>
            <select id="sql-dialect-select" data-action="change-dialect" style="margin-right: 10px;">
              <option value="snowflake" ${state.sqlDialect === 'snowflake' ? 'selected' : ''}>Snowflake</option>
              <option value="postgresql" ${state.sqlDialect === 'postgresql' ? 'selected' : ''}>PostgreSQL</option>
            </select>
            <button data-action="copy-sql" style="margin-right: 10px;">Copy</button>
            <button class="close-btn" data-action="close-sql" aria-label="Close SQL modal">×</button>
          </div>
        </div>
        <textarea class="sql-output" readonly>${generateSQL(state.visibleColumns, state.sqlDialect)}</textarea>
      </div>
    </div>
  `;
};

const renderJsonModal = () => {
  if (!state.showJsonModal) return '';
  return `
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="json-modal-title">
      <div id="json-modal-content" class="modal-content" style="width: 900px; height: 80vh; display: flex; flex-direction: column;">
        <div class="modal-header">
          <h3 id="json-modal-title">Raw Data (JSON, CSV, TSV)</h3>
          <button class="close-btn" data-action="close-json" aria-label="Close raw data modal">×</button>
        </div>
        <textarea 
            id="json-edit-area" 
            class="json-edit-output" 
            aria-label="Raw JSON, CSV, or TSV editor"
            style="flex-grow: 1; width: 100%; resize: none; margin-bottom: 10px; font-family: 'Consolas', monospace;"
            placeholder="Paste JSON, CSV, or TSV data here, or load from file."
        >${state.rawJsonEditContent}</textarea>
        <div class="modal-footer" style="display: flex; justify-content: space-between; align-items: center; padding-top:10px; border-top: 1px solid #eee;">
          <div class="json-modal-actions-left">
            <input type="file" id="json-file-input" accept=".json,.csv,.tsv,.txt" style="display: none;">
            <button data-action="trigger-file-load" style="margin-right: 10px;">Load File</button>
            <button data-action="select-all-json" style="margin-right: 10px;">Select All</button>
            <button data-action="copy-json" style="margin-right: 10px;">Copy</button>
            <button data-action="clear-json" style="margin-right: 10px;">Clear</button>
            <button data-action="validate-json">Validate JSON</button>
          </div>
          <div class="json-modal-actions-right">
              <button data-action="apply-json-changes" style="margin-left: 10px; background-color: #28a745; color:white; border:none; padding: 8px 12px; border-radius:4px; cursor:pointer;">Apply & Close</button>
          </div>
        </div>
         <span class="json-validation-status" role="status" aria-live="polite" aria-atomic="true" style="font-size: 12px; min-height: 1.2em; margin-top: 5px; text-align: right;">${state.jsonValidationMessage}</span>
      </div>
    </div>
  `;
};

const renderPromoteKeyPopover = () => {
  if (!state.showPromoteKeyPopover || !state.promoteKeyPopoverContext) {
      return '';
  }
  const { targetElementRect, pathToArrayElement, valueFieldName, siblingKeysAndValues } = state.promoteKeyPopoverContext;
  const popoverTop = targetElementRect.bottom + window.scrollY + 5;
  const popoverLeft = targetElementRect.left + window.scrollX;
  const popoverStyle = `
      position: absolute; top: ${popoverTop}px; left: ${popoverLeft}px;
      background-color: white; border: 1px solid #ccc; border-radius: 4px;
      padding: 10px; z-index: 1050; box-shadow: 0 2px 10px rgba(0,0,0,0.15);
      font-size: 0.9em; min-width: 200px;
  `;
  const arrayName = pathToArrayElement.substring(0, pathToArrayElement.lastIndexOf('['));
  const itemIdentifierInArray = pathToArrayElement.substring(pathToArrayElement.lastIndexOf('['));
  let content = `<div style="margin-bottom: 8px; font-weight: bold;">Promote field: <code>${valueFieldName}</code></div>`;
  content += `<div style="margin-bottom: 8px; font-size: 0.9em;">From item in <code>${arrayName}</code>. Identify this item by:</div>`;
  content += '<ul style="list-style: none; padding: 0; margin: 0;">';
  siblingKeysAndValues.forEach(skv => {
      let displayValue = String(skv.value);
      if (displayValue.length > 25) displayValue = displayValue.substring(0, 22) + "...";
      content += `
          <li style="margin-bottom: 5px;">
              <button class="promote-popover-btn" data-action="confirm-promote-with-key" data-selected-key="${escapeStringForDataAttribute(skv.key)}">
                  ${skv.key}: "${escapeStringForDataAttribute(displayValue)}"
              </button>
          </li>`;
  });
  content += `
      <li style="margin-bottom: 5px;">
          <button class="promote-popover-btn" data-action="confirm-promote-with-key" data-selected-key="INDEX">
              Original position (<code>${itemIdentifierInArray}</code>)
          </button>
      </li>
      <li style="margin-top: 10px; border-top: 1px solid #eee; padding-top: 8px;">
          <button class="promote-popover-btn promote-popover-cancel-btn" data-action="cancel-promote-popover">Cancel</button>
      </li>
  </ul>`;
  return `<div id="promote-key-popover" class="promote-key-popover" style="${popoverStyle}" role="dialog" aria-modal="true" aria-labelledby="promote-key-popover-title">
              <h4 id="promote-key-popover-title" class="sr-only">Promote Key Options</h4>
              ${content}
          </div>`;
};

const renderAddColumnPopover = () => {
  if (!state.showAddColumnPopover || !state.addColumnPopoverAnchor) return '';
  const anchorRect = state.addColumnPopoverAnchor.getBoundingClientRect();
  const popoverTop = anchorRect.bottom + window.scrollY + 5;
  const popoverWidth = 250;
  let popoverLeft = anchorRect.left + window.scrollX;
  if (popoverLeft + popoverWidth > window.innerWidth) popoverLeft = anchorRect.right + window.scrollX - popoverWidth;
  popoverLeft = Math.max(0, popoverLeft);
  const popoverStyle = `
      position: absolute; top: ${popoverTop}px; left: ${popoverLeft}px;
      background-color: white; border: 1px solid #ccc; border-radius: 4px;
      padding: 10px; z-index: 1050; box-shadow: 0 2px 10px rgba(0,0,0,0.15);
      font-size: 0.9em; min-width: ${popoverWidth}px; max-height: 300px; overflow-y: auto;
  `;
  const availableColumnsToAdd = [...state.allPossibleColumns].filter(
      col => !state.visibleColumns.includes(col)
  ).sort((a,b) => a.localeCompare(b, undefined, {sensitivity: 'base'}));
  let content = `<div style="margin-bottom: 8px; font-weight: bold; padding-bottom: 5px; border-bottom: 1px solid #eee;">Available Columns to Add</div>`;
  if (availableColumnsToAdd.length === 0) {
      content += '<div style="padding: 5px 0;"><i>No more columns to add.</i></div>';
  } else {
      content += '<ul style="list-style: none; padding: 0; margin: 0;">';
      availableColumnsToAdd.forEach(col => {
          content += `
              <li style="margin-bottom: 5px;">
                  <button class="add-column-popover-btn" data-action="add-column-from-popover" data-column-to-add="${escapeStringForDataAttribute(col)}" title="Add column: ${escapeStringForDataAttribute(col)}">
                     + ${escapeStringForDataAttribute(col)}
                  </button>
              </li>`;
      });
      content += '</ul>';
  }
  content += `
      <div style="margin-top: 10px; border-top: 1px solid #eee; padding-top: 8px; text-align: right;">
          <button class="add-column-popover-cancel-btn" data-action="cancel-add-column-popover">Close</button>
      </div>
  `;
  return `<div id="add-column-popover" class="add-column-popover" style="${popoverStyle}" role="dialog" aria-modal="true" aria-labelledby="add-column-popover-title">
              <h4 id="add-column-popover-title" class="sr-only">Reinstate Column</h4>
              ${content}
          </div>`;
};

// Drag-and-drop state
let dragSourceElement = null;

// Drag-and-Drop Handlers for Column Reordering
function handleThDragStart(e) {
  if (!state.editModeActive) return;
  this.classList.add('dragging');
  dragSourceElement = this;
  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/plain', this.dataset.column);
}

function handleThDragOver(e) {
  if (!state.editModeActive || !dragSourceElement) return;
  e.preventDefault();
  e.dataTransfer.dropEffect = 'move';
  if (this !== dragSourceElement) this.classList.add('drag-over');
  return false;
}

function handleThDragEnter(e) {
  if (!state.editModeActive || !dragSourceElement) return;
  e.preventDefault();
  if (this !== dragSourceElement) this.classList.add('drag-over');
}

function handleThDragLeave() {
  if (!state.editModeActive) return;
  this.classList.remove('drag-over');
}

function handleThDrop(e) {
  if (!state.editModeActive || !dragSourceElement) return;
  e.stopPropagation(); 
  e.preventDefault();  
  this.classList.remove('drag-over');
  if (dragSourceElement !== this) {
      const sourceColumnEncoded = e.dataTransfer.getData('text/plain');
      const targetColumnEncoded = this.dataset.column;
      const sourceColumn = decodeURIComponent(sourceColumnEncoded);
      const targetColumn = decodeURIComponent(targetColumnEncoded);
      const currentCols = [...state.visibleColumns];
      const sourceIndex = currentCols.indexOf(sourceColumn);
      const targetIndex = currentCols.indexOf(targetColumn);
      if (sourceIndex !== -1 && targetIndex !== -1 && sourceIndex !== targetIndex) {
          const [movedItem] = currentCols.splice(sourceIndex, 1); 
          currentCols.splice(targetIndex, 0, movedItem);          
          state.visibleColumns = currentCols; 
      }
  }
  return false;
}

function handleThDragEnd() {
  if (!state.editModeActive) return;
  this.classList.remove('dragging');
  const tableHead = this.closest('thead');
  if (tableHead) {
      tableHead.querySelectorAll('th.drag-over').forEach(th => th.classList.remove('drag-over'));
  }
  dragSourceElement = null; 
}

const render = () => {
  const appElement = document.getElementById('app');
  if (!appElement) return;
  
  const activeElement = document.activeElement;
  let activeElementId = activeElement ? activeElement.id : null;
  let selectionStart, selectionEnd;
  let sqlSelectValue = state.sqlDialect; // Preserve select value

  if (activeElement) {
      if (activeElement.id === 'json-browser-search-box' || activeElement.id === 'json-edit-area') {
        selectionStart = activeElement.selectionStart;
        selectionEnd = activeElement.selectionEnd;
      }
      // Store current value of SQL dialect select if it's focused or modal is open
      if (activeElement.id === 'sql-dialect-select' || state.showSqlModal) {
          const sqlSelect = document.getElementById('sql-dialect-select');
          if(sqlSelect) sqlSelectValue = sqlSelect.value;
      }
  }


  const jsonTableElement = appElement.querySelector('.json-table');
  let mainScrollLeft = 0;
  let mainScrollTop = 0;

  if (jsonTableElement) {
      mainScrollLeft = jsonTableElement.scrollLeft; 
      mainScrollTop = jsonTableElement.scrollTop;
  }
  
  appElement.innerHTML = `
    ${renderHeader()}
    ${renderTable()}
    ${renderSqlModal()} 
    ${renderJsonModal()}
    ${renderPromoteKeyPopover()}
    ${renderAddColumnPopover()} 
    ${renderCsvModal()} 
  `;

  // Add event listener to the SQL modal's select to stop click propagation
  const sqlModalDialog = document.getElementById('sql-modal-dialog');
  if (sqlModalDialog) {
      const sqlSelectElement = sqlModalDialog.querySelector('#sql-dialect-select');
      if (sqlSelectElement && !sqlSelectElement.dataset.clickListenerAttached) {
          sqlSelectElement.addEventListener('click', (e) => {
              e.stopPropagation();
          });
          sqlSelectElement.dataset.clickListenerAttached = 'true'; // Mark as attached
      }
  }
  // Also, re-apply the value to the select if it was re-rendered
  if (state.showSqlModal) {
      const newSqlSelect = document.getElementById('sql-dialect-select');
      if (newSqlSelect && newSqlSelect.value !== sqlSelectValue) {
          newSqlSelect.value = sqlSelectValue;
      }
  }


  if (state.showJsonModal) {
      const jsonEditArea = document.getElementById('json-edit-area');
      const modalContentElement = document.getElementById('json-modal-content'); 
      const modalContentTarget = modalContentElement || jsonEditArea;
      
      if (modalContentTarget && !modalContentTarget.dataset.dndListenersAttached) {
          modalContentTarget.dataset.dndListenersAttached = 'true';
          const dragOverHandler = (e) => { e.preventDefault(); e.stopPropagation(); e.dataTransfer.dropEffect = 'copy'; modalContentTarget.classList.add('drag-over-active'); };
          const dragLeaveHandler = (e) => { e.preventDefault(); e.stopPropagation(); modalContentTarget.classList.remove('drag-over-active'); };
          const dropHandler = (e) => {
              e.preventDefault(); e.stopPropagation(); modalContentTarget.classList.remove('drag-over-active');
              const files = e.dataTransfer.files;
              if (files.length > 0) {
                  const file = files[0];
                  const reader = new FileReader();
                  reader.onload = (loadEvent) => {
                      if (loadEvent.target && typeof loadEvent.target.result === 'string') {
                          state.rawJsonEditContent = loadEvent.target.result;
                          state.jsonValidationMessage = 'File dropped. Validate or Apply & Close.';
                          state.notify('rawJsonEditContent');
                          state.notify('jsonValidationMessage');
                      } else {
                         state.jsonValidationMessage = '<span style="color: red;">Error: Could not read dropped file content.</span>';
                         state.notify('jsonValidationMessage');
                      }
                  };
                  reader.onerror = () => { 
                      state.jsonValidationMessage = '<span style="color: red;">Error reading dropped file.</span>'; 
                      state.notify('jsonValidationMessage');
                  };
                  reader.readAsText(file);
              }
          };
          modalContentTarget.addEventListener('dragover', dragOverHandler);
          modalContentTarget.addEventListener('dragleave', dragLeaveHandler);
          modalContentTarget.addEventListener('drop', dropHandler);
          modalContentTarget._dndHandlers = { dragOverHandler, dragLeaveHandler, dropHandler };
      }
  } else {
      const modalContentTarget = document.getElementById('json-modal-content') || document.getElementById('json-edit-area');
      if (modalContentTarget && modalContentTarget.dataset.dndListenersAttached) {
          if (modalContentTarget._dndHandlers) {
              modalContentTarget.removeEventListener('dragover', modalContentTarget._dndHandlers.dragOverHandler);
              modalContentTarget.removeEventListener('dragleave', modalContentTarget._dndHandlers.dragLeaveHandler);
              modalContentTarget.removeEventListener('drop', modalContentTarget._dndHandlers.dropHandler);
              delete modalContentTarget._dndHandlers;
          }
          delete modalContentTarget.dataset.dndListenersAttached;
          modalContentTarget.classList.remove('drag-over-active');
      }
  }

  const newJsonTableElement = appElement.querySelector('.json-table');
  if (newJsonTableElement) {
      if (mainScrollTop !== undefined) newJsonTableElement.scrollTop = mainScrollTop;
      if (mainScrollLeft !== undefined) newJsonTableElement.scrollLeft = mainScrollLeft; 
  }

  if (state.editModeActive) {
      const thElements = appElement.querySelectorAll('table > thead > tr > th[data-column][draggable="true"]');
      thElements.forEach(th => {
          th.addEventListener('dragstart', handleThDragStart);
          th.addEventListener('dragenter', handleThDragEnter);
          th.addEventListener('dragover', handleThDragOver);
          th.addEventListener('dragleave', handleThDragLeave);
          th.addEventListener('drop', handleThDrop);
          th.addEventListener('dragend', handleThDragEnd);
      });
  }

  if (activeElementId) {
      const newActiveElement = document.getElementById(activeElementId);
      if (newActiveElement && document.activeElement !== newActiveElement) { 
        if (newActiveElement.id === 'sql-dialect-select' && newActiveElement.value !== sqlSelectValue) {
            newActiveElement.value = sqlSelectValue; // Ensure value is set before focusing
        }
          newActiveElement.focus();
          if ((activeElementId === 'json-browser-search-box' || activeElementId === 'json-edit-area') && 
              selectionStart !== undefined && selectionEnd !== undefined && typeof newActiveElement.setSelectionRange === 'function') {
              try { newActiveElement.setSelectionRange(selectionStart, selectionEnd); } catch (ex) { /* ignore */ }
          }
      }
  }
  if (state.showJsonModal) {
      const jsonEditArea = document.getElementById('json-edit-area');
      if (jsonEditArea && jsonEditArea.value !== state.rawJsonEditContent) {
          jsonEditArea.value = state.rawJsonEditContent; 
          if (activeElementId === 'json-edit-area' && document.getElementById(activeElementId) === jsonEditArea && typeof jsonEditArea.setSelectionRange === 'function') {
               try { jsonEditArea.setSelectionRange(selectionStart, selectionEnd); } catch (ex) {/* ignore */}
          }
      }
  }
};
// --- END OF INLINED ui.js ---

// --- START OF INLINED basic.js (entry point) ---

// basic.js

// Assuming debounce is in utils.js, otherwise define it here or let lastExecutedSearchQuery = null; // Keep this to know if a search has been made

function blurSearchBox() {
    const searchBox = document.getElementById('json-browser-search-box');
    if (searchBox) {
        searchBox.blur();
    }
}

function focusSearchBox() {
    const searchBox = document.getElementById('json-browser-search-box');
    if (searchBox) {
        searchBox.focus();
        searchBox.select(); // Optional: also select existing text
    }
}

// calledFromEnterInSearchBox is true if user pressed Enter while search box was focused.
function executeSearchLogic(calledFromEnterInSearchBox = false) {
    let queryToSearch = state.searchQuery;

    if (calledFromEnterInSearchBox) {
        const searchBox = document.getElementById('json-browser-search-box');
        if (searchBox && searchBox.value !== state.searchQuery) {
            queryToSearch = searchBox.value;
            state.searchQuery = queryToSearch;
        }
    }
    
    if (queryToSearch.trim() === '') {
        state.searchResults = [];
        state.currentSearchIndex = -1;
        lastExecutedSearchQuery = null; 
        state.notify('searchResults'); // This will also trigger re-render using the new currentSearchIndex
    } else {
        state.searchResults = performSearch(state.data, queryToSearch);
        const oldSearchIndex = state.currentSearchIndex;
        state.currentSearchIndex = state.searchResults.length > 0 ? 0 : -1;
        lastExecutedSearchQuery = queryToSearch;
        
        state.notify('searchResults'); // Notifies about the new list and its length.
        // If currentSearchIndex changed and searchResults notification doesn't implicitly handle it for render, notify explicitly.
        // However, usually a 'searchResults' change implies re-evaluation of highlights based on currentSearchIndex.
        // For robustness, if currentSearchIndex changed meaningfully (e.g. from -1 to 0, or 0 to -1)
        // and the 'searchResults' notification isn't guaranteed to refresh highlighting logic for the index:
        if (state.currentSearchIndex !== oldSearchIndex && state.currentSearchIndex !== -1) { // Check if it actually changed to a valid index
             // state.notify('currentSearchIndex'); // Potentially redundant if render() always uses latest state.currentSearchIndex
                                                 // when 'searchResults' changes. Let's assume render is robust.
        }

        if (state.searchResults.length > 0 && state.currentSearchIndex !== -1) {
            expandToResult(state.searchResults[state.currentSearchIndex]);
        }
        // No explicit 'else { state.notify('searchResults'); }' needed here as it's covered by the initial notify or the one above.
    }
    // Blurring is now handled by the explicit action callers (Enter in box, Search button)
}

const debouncedExecuteSearch = debounce(() => executeSearchLogic(false), 300); // 300ms delay

const handleKeyboard = (e) => {
  const searchBox = document.getElementById('json-browser-search-box');
  const searchBoxFocused = document.activeElement === searchBox;
  const jsonEditAreaFocused = e.target.id === 'json-edit-area';
  const inModal = e.target.closest('.modal');
  const inPromotePopover = e.target.closest('#promote-key-popover');
  const inAddColumnPopover = e.target.closest('#add-column-popover');

  // CTRL+F / CMD+F to focus search box
  if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
    if (!jsonEditAreaFocused && !e.target.matches('textarea:not(#json-browser-search-box)')) {
        e.preventDefault();
        focusSearchBox();
        return; 
    }
  }

  if (e.key === 'Enter') {
    if (searchBoxFocused) {
      e.preventDefault();
      executeSearchLogic(true); 
      blurSearchBox();          
    } else if (state.searchResults.length > 0 && lastExecutedSearchQuery !== null) {
      e.preventDefault();
      state.currentSearchIndex = (state.currentSearchIndex + 1) % state.searchResults.length;
      state.notify('currentSearchIndex'); // Notify that the active search result index has changed
      expandToResult(state.searchResults[state.currentSearchIndex]);
    }
  } else if (e.key === 'Escape') {
    if (searchBoxFocused) {
        e.preventDefault();
        state.searchQuery = '';
        if(searchBox) searchBox.value = '';
        state.searchResults = [];
        state.currentSearchIndex = -1;
        lastExecutedSearchQuery = null; 
        state.notify('searchResults'); // Covers currentSearchIndex update too
        blurSearchBox(); 
    } else if (state.showAddColumnPopover) { 
        e.preventDefault();
        const cancelButton = document.querySelector('#add-column-popover .add-column-popover-cancel-btn');
        if (cancelButton) cancelButton.click();
        else {
            closeModalFocus('#add-column-popover');
            state.showAddColumnPopover = false;
            if (state.addColumnPopoverAnchor) state.addColumnPopoverAnchor.focus();
            state.addColumnPopoverAnchor = null;
            state.notify('showAddColumnPopover');
        }
    } else if (state.showPromoteKeyPopover) { 
        e.preventDefault();
        const cancelButton = document.querySelector('#promote-key-popover .promote-popover-cancel-btn');
        if (cancelButton) cancelButton.click();
        else {
            closeModalFocus('#promote-key-popover');
            state.showPromoteKeyPopover = false;
            if (state.promoteKeyPopoverContext && state.promoteKeyPopoverContext.triggerElement) {
                state.promoteKeyPopoverContext.triggerElement.focus();
            }
            state.promoteKeyPopoverContext = null;
            state.notify('showPromoteKeyPopover');
        }
    } else if (state.showSqlModal && inModal) { 
        e.preventDefault();
        closeModalFocus('.modal[aria-labelledby="sql-modal-title"]');
        state.showSqlModal = false; state.notify('showSqlModal');
    } else if (state.showCsvModal && inModal) { 
        e.preventDefault();
        closeModalFocus('.modal[aria-labelledby="csv-modal-title"]');
        state.showCsvModal = false; state.notify('showCsvModal');
    } else if (state.showJsonModal && inModal && !jsonEditAreaFocused) { 
        e.preventDefault();
        closeModalFocus('.modal[aria-labelledby="json-modal-title"]');
        state.showJsonModal = false; state.jsonValidationMessage = '';
        state.notify('showJsonModal');
    } else if (state.editModeActive && !searchBoxFocused && !jsonEditAreaFocused && !inModal && !inPromotePopover && !inAddColumnPopover) {
        e.preventDefault();
        state.editModeActive = false; state.notify('editModeActive');
    }
  }

  if ((e.key === 'Enter' || e.key === ' ') &&
      (e.target.matches('.expandable[role="button"]') || e.target.matches('th[role="button"]'))) {
      if (! (e.key === 'Enter' && (searchBoxFocused || (state.searchResults.length > 0 && lastExecutedSearchQuery !== null) ) ) ) {
        e.preventDefault();
        e.target.click();
      }
  }
};

const handleEvent = (e) => {
  const eventTarget = e.target;

  if (state.showAddColumnPopover) {
      const popoverElement = document.querySelector('#add-column-popover');
      const clickedAddColumnButton = eventTarget.closest('[data-action="show-add-column-popover"]');
      const clickedInsidePopover = popoverElement && popoverElement.contains(eventTarget);
      if (!clickedInsidePopover && !clickedAddColumnButton) {
          const cancelButton = document.querySelector('#add-column-popover .add-column-popover-cancel-btn');
          if (cancelButton) cancelButton.click(); else { closeModalFocus('#add-column-popover'); state.showAddColumnPopover = false; if (state.addColumnPopoverAnchor) state.addColumnPopoverAnchor.focus(); state.addColumnPopoverAnchor = null; state.notify('showAddColumnPopover');}
      }
  }
  if (state.showPromoteKeyPopover) {
      const popoverElement = document.querySelector('#promote-key-popover');
      const clickedPromoteButton = eventTarget.closest('[data-action="promote-value"]');
      const clickedInsidePopover = popoverElement && popoverElement.contains(eventTarget);
      if (!clickedInsidePopover && !clickedPromoteButton) {
          const cancelButton = document.querySelector('#promote-key-popover .promote-popover-cancel-btn');
           if (cancelButton) cancelButton.click(); else { closeModalFocus('#promote-key-popover'); state.showPromoteKeyPopover = false; if (state.promoteKeyPopoverContext && state.promoteKeyPopoverContext.triggerElement) state.promoteKeyPopoverContext.triggerElement.focus(); state.promoteKeyPopoverContext = null; state.notify('showPromoteKeyPopover');}
      }
  }

  let target = eventTarget;
  let action = target.dataset.action;

  if (!action && target.closest('[data-action]')) {
      target = target.closest('[data-action]');
      action = target.dataset.action;
  }
  if (!action) return;

  const { path, row, column } = target.dataset;

  switch (action) {
    case 'search': 
      if (state.searchQuery !== target.value) {
        state.searchQuery = target.value;
        if (state.searchQuery.trim() === '') {
            state.searchResults = [];
            state.currentSearchIndex = -1;
            lastExecutedSearchQuery = null;
            state.notify('searchResults'); // Covers currentSearchIndex update
        } else {
            debouncedExecuteSearch();
        }
      }
      break;
    case 'execute-search': 
        const searchInput = document.getElementById('json-browser-search-box');
        if (searchInput && state.searchQuery !== searchInput.value) {
            state.searchQuery = searchInput.value;
        }
        executeSearchLogic(false); 
        blurSearchBox();           
        break;
    case 'search-next':
      if (state.searchResults.length > 0) {
        state.currentSearchIndex = (state.currentSearchIndex + 1) % state.searchResults.length;
        state.notify('currentSearchIndex'); // Notify that the active search result index has changed
        expandToResult(state.searchResults[state.currentSearchIndex]);
      }
      break;
    case 'search-prev':
      if (state.searchResults.length > 0) {
        state.currentSearchIndex = (state.currentSearchIndex - 1 + state.searchResults.length) % state.searchResults.length;
        state.notify('currentSearchIndex'); // Notify that the active search result index has changed
        expandToResult(state.searchResults[state.currentSearchIndex]);
      }
      break;
    case 'toggle':
      const expandKey = `${row}-${path}`;
      if (state.expandedPaths.has(expandKey)) state.expandedPaths.delete(expandKey);
      else state.expandedPaths.add(expandKey);
      state.notify('expandedPaths');
      break;
    case 'expand-all':
      state.data.forEach((rowData, rowIndex) => {
        getAllObjectPaths(rowData).forEach(itemPath => state.expandedPaths.add(`${rowIndex}-${itemPath}`));
      });
      state.notify('expandedPaths');
      break;
    case 'collapse-all':
      state.expandedPaths.clear();
      state.notify('expandedPaths');
      break;
    case 'toggle-paths':
      state.showPaths = !state.showPaths;
      state.notify('showPaths');
      break;
    case 'toggle-edit-mode':
      state.editModeActive = !state.editModeActive;
      if (!state.editModeActive) {
          if (state.showPromoteKeyPopover) { state.showPromoteKeyPopover = false; state.promoteKeyPopoverContext = null; state.notify('showPromoteKeyPopover'); }
          if (state.showAddColumnPopover) { state.showAddColumnPopover = false; state.addColumnPopoverAnchor = null; state.notify('showAddColumnPopover'); }
      }
      state.notify('editModeActive'); 
      break;
    case 'promote-value':
      const pathClicked = target.dataset.pathToValue;
      const rowIndexForContext = parseInt(target.dataset.rowIndex);
      const rowData = state.data[rowIndexForContext];
      const lastDotIndex = pathClicked.lastIndexOf('.');
      if (lastDotIndex === -1) {
          if (!state.visibleColumns.includes(pathClicked)) {
              state.visibleColumns = [...state.visibleColumns, pathClicked];
              updateAllPossibleColumns();
              state.notify('visibleColumns');
          }
          if (state.showPromoteKeyPopover) { state.showPromoteKeyPopover = false; state.promoteKeyPopoverContext = null; state.notify('showPromoteKeyPopover'); }
          break;
      }
      const parentObjectPath = pathClicked.substring(0, lastDotIndex);
      const fieldName = pathClicked.substring(lastDotIndex + 1);
      const arrayElementMatch = parentObjectPath.match(/^(.*)\[(\d+)\]$/);
      if (arrayElementMatch) {
          const pathToArrayElement = parentObjectPath;
          const objectInArray = getValue(rowData, pathToArrayElement);
          if (objectInArray && typeof objectInArray === 'object' && !Array.isArray(objectInArray)) {
              const siblingKeysAndValues = [];
              for (const key in objectInArray) {
                  const val = objectInArray[key];
                  if (typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean') {
                      siblingKeysAndValues.push({ key, value: val });
                  }
              }
              if (siblingKeysAndValues.length > 0) {
                  state.promoteKeyPopoverContext = {
                      rowIndex: rowIndexForContext, originalPathToValue: pathClicked,
                      pathToArrayElement: pathToArrayElement, valueFieldName: fieldName,
                      targetElementRect: target.getBoundingClientRect(), siblingKeysAndValues,
                      triggerElement: target,
                  };
                  state.showPromoteKeyPopover = true;
                  state.notify('showPromoteKeyPopover');
                  return; 
              }
          }
      }
      if (!state.visibleColumns.includes(pathClicked)) {
          state.visibleColumns = [...state.visibleColumns, pathClicked];
          updateAllPossibleColumns();
          state.notify('visibleColumns');
      }
      if (state.showPromoteKeyPopover) { state.showPromoteKeyPopover = false; state.promoteKeyPopoverContext = null; state.notify('showPromoteKeyPopover');}
      break;
    case 'confirm-promote-with-key':
      if (!state.promoteKeyPopoverContext) break;
      const { rowIndex, originalPathToValue, pathToArrayElement, valueFieldName, triggerElement: promoteTrigger } = state.promoteKeyPopoverContext;
      const selectedKeyForId = target.dataset.selectedKey;
      const rowDataForPromotion = state.data[rowIndex];
      let pathToPromote;
      if (selectedKeyForId === 'INDEX') {
          pathToPromote = originalPathToValue;
      } else {
          const arrayBasePath = pathToArrayElement.substring(0, pathToArrayElement.lastIndexOf('['));
          const objectInArray = getValue(rowDataForPromotion, pathToArrayElement);
          if (objectInArray && typeof objectInArray === 'object' && objectInArray.hasOwnProperty(selectedKeyForId)) {
              const identifyingKeyValue = String(objectInArray[selectedKeyForId]);
              const safeIdentifyingKeyValue = identifyingKeyValue.replace(/"/g, '\\"');
              pathToPromote = `${arrayBasePath}[${selectedKeyForId}="${safeIdentifyingKeyValue}"].${valueFieldName}`;
          } else {
              pathToPromote = originalPathToValue;
              console.warn("Could not find selected key for promotion, falling back to index path.");
          }
      }
      if (!state.visibleColumns.includes(pathToPromote)) {
          state.visibleColumns = [...state.visibleColumns, pathToPromote];
          updateAllPossibleColumns();
          state.notify('visibleColumns');
      }
      closeModalFocus('#promote-key-popover');
      state.showPromoteKeyPopover = false;
      state.promoteKeyPopoverContext = null;
      state.notify('showPromoteKeyPopover');
      if (promoteTrigger) requestAnimationFrame(() => promoteTrigger.focus());
      break;
    case 'cancel-promote-popover':
      const promoteAnchor = state.promoteKeyPopoverContext ? state.promoteKeyPopoverContext.triggerElement : null;
      closeModalFocus('#promote-key-popover');
      state.showPromoteKeyPopover = false;
      state.promoteKeyPopoverContext = null;
      state.notify('showPromoteKeyPopover');
      if (promoteAnchor) requestAnimationFrame(() => promoteAnchor.focus());
      break;
    case 'sort':
        const sortColumn = decodeURIComponent(column);
        if (state.sortBy === sortColumn) state.sortDirection = state.sortDirection === 'asc' ? 'desc' : 'asc';
        else { state.sortBy = sortColumn; state.sortDirection = 'asc'; }
        state.notify('sort');
        break;
    case 'remove-column-header':
        const colToRemove = decodeURIComponent(target.dataset.column);
        state.visibleColumns = state.visibleColumns.filter(c => c !== colToRemove);
        if (state.sortBy === colToRemove) { state.sortBy = null; state.sortDirection = 'asc'; } // Reset sort if sorted column is removed
        state.notify('visibleColumns'); // Notify about visibleColumns change
        state.notify('sort'); // Also notify sort, in case sortBy was reset
        break;
    case 'show-sql': state.showSqlModal = true; state.notify('showSqlModal'); break;
    case 'close-sql':
      closeModalFocus('.modal[aria-labelledby="sql-modal-title"]');
      state.showSqlModal = false;
      state.notify('showSqlModal');
      break;
    case 'change-dialect': state.sqlDialect = target.value; state.notify('sqlDialect'); break;
    case 'copy-sql':
      {
        const sqlOutputElement = document.querySelector('.sql-output');
        if (sqlOutputElement) {
          navigator.clipboard.writeText(sqlOutputElement.value).then(() => {
            target.textContent = 'Copied!'; setTimeout(() => target.textContent = 'Copy', 2000);
          }).catch(err => {
              console.error('Failed to copy SQL: ', err);
              target.textContent = 'Failed!'; setTimeout(() => target.textContent = 'Copy', 2000);
          });
        }
      }
      break;
    case 'show-json':
      if (!state.showJsonModal) {
        try {
          state.rawJsonEditContent = state.data.length > 0 ? JSON.stringify(state.data, null, 2) : '';
        } catch (e) {
           console.error("Error stringifying data for JSON modal:", e);
           state.rawJsonEditContent = "Error: Could not serialize current data. Please clear and paste new data.";
        }
        state.jsonValidationMessage = state.data.length === 0 ? 'Paste or load data.' : '';
      }
      state.showJsonModal = true;
      state.notify('showJsonModal'); 
      break;
    case 'close-json':
      closeModalFocus('.modal[aria-labelledby="json-modal-title"]');
      state.showJsonModal = false; state.jsonValidationMessage = '';
      state.notify('showJsonModal');
      break;
    case 'trigger-file-load':
      document.getElementById('json-file-input')?.click();
      break;
    case 'clear-json':
      state.rawJsonEditContent = '';
      const jsonEditAreaForClear = document.getElementById('json-edit-area');
      if (jsonEditAreaForClear) jsonEditAreaForClear.value = '';
      state.jsonValidationMessage = 'Paste or load data.';
      state.notify('rawJsonEditContent'); 
      state.notify('jsonValidationMessage');
      break;
    case 'select-all-json':
      const jsonEditAreaSelect = document.getElementById('json-edit-area');
      if (jsonEditAreaSelect) { jsonEditAreaSelect.focus(); jsonEditAreaSelect.select(); }
      break;
    case 'copy-json':
      const jsonEditAreaCopy = document.getElementById('json-edit-area');
      if (jsonEditAreaCopy) {
          navigator.clipboard.writeText(jsonEditAreaCopy.value).then(() => {
              state.jsonValidationMessage = '<span style="color: green;">Copied to clipboard!</span>';
              state.notify('jsonValidationMessage');
          }).catch(err => {
              console.error('Failed to copy JSON: ', err);
              state.jsonValidationMessage = '<span style="color: red;">Failed to copy.</span>';
              state.notify('jsonValidationMessage');
          });
      }
      break;
    case 'validate-json':
      try {
        const jsonEditAreaVal = document.getElementById('json-edit-area');
        const currentTextVal = jsonEditAreaVal ? jsonEditAreaVal.value : state.rawJsonEditContent;
        const parsedJson = JSON.parse(currentTextVal);
        state.rawJsonEditContent = JSON.stringify(parsedJson, null, 2); 
        state.jsonValidationMessage = '<span style="color: green;">JSON is valid.</span>';
      } catch (err) {
        state.jsonValidationMessage = `<span style="color: red;">Invalid JSON: ${err.message}</span>`;
      }
      state.notify('jsonValidationMessage'); 
      state.notify('rawJsonEditContent');   
      break;
    case 'apply-json-changes':
      {
          const jsonEditAreaApply = document.getElementById('json-edit-area');
          const currentTextApply = jsonEditAreaApply ? jsonEditAreaApply.value : state.rawJsonEditContent;
          let parsedData = null; let parseMethod = ''; let detectedHeaders = [];
          robustParseCSV.lastHeaders = []; 
          if (currentTextApply.trim() === '') { parsedData = []; parseMethod = 'empty'; }
          else {
              try {
                  const jsonData = JSON.parse(currentTextApply);
                  if (Array.isArray(jsonData)) { parsedData = jsonData; parseMethod = 'JSON'; }
                  else if (typeof jsonData === 'object' && jsonData !== null) { parsedData = [jsonData]; parseMethod = 'JSON (single object)';}
              } catch (e) {  }

              if (parsedData === null) { 
                  try {
                      const delimiter = detectDelimiter(currentTextApply.substring(0, Math.min(currentTextApply.length, 2000)));
                      const csvObjects = robustParseCSV(currentTextApply, delimiter);
                      detectedHeaders = robustParseCSV.lastHeaders; 
                      if (csvObjects.length > 0 || (detectedHeaders.length > 0 && detectedHeaders.some(h => h !== ''))) {
                         parsedData = csvObjects; parseMethod = delimiter === '\t' ? 'TSV' : 'CSV';
                         if (csvObjects.length === 0 && detectedHeaders.length > 0) parseMethod += ' (headers only)';
                      }
                  } catch (csvErr) { console.error("CSV parsing error during apply:", csvErr); }
              }
          }

          if (parsedData !== null) {
              state.data = parsedData;
              closeModalFocus('.modal[aria-labelledby="json-modal-title"]');
              state.showJsonModal = false; state.jsonValidationMessage = '';
              let newVisibleColumns = [];
              if (detectedHeaders.length > 0 && detectedHeaders.some(h => h && h.trim() !== '')) {
                newVisibleColumns = detectedHeaders.filter(h => h && h.trim() !== '');
              } else if (state.data.length > 0 && typeof state.data[0] === 'object' && state.data[0] !== null) {
                newVisibleColumns = Object.keys(state.data[0]); 
              }
              state.visibleColumns = newVisibleColumns;
              updateAllPossibleColumns(); 
              state.searchQuery = ''; state.searchResults = []; state.currentSearchIndex = -1;
              lastExecutedSearchQuery = null; 
              state.expandedPaths.clear(); state.sortBy = null;
              state.notify('dataApplied'); 
              console.log(`Data applied successfully using ${parseMethod} parser.`);
          } else {
              state.jsonValidationMessage = '<span style="color: red;">Cannot apply: Invalid data format. Not recognized as JSON, CSV, or TSV.</span>';
              state.notify('jsonValidationMessage');
          }
      }
      break;
    case 'show-add-column-popover':
      state.addColumnPopoverAnchor = target; state.showAddColumnPopover = true;
      state.notify('showAddColumnPopover');
      break;
    case 'cancel-add-column-popover':
      const addColumnAnchor = state.addColumnPopoverAnchor;
      closeModalFocus('#add-column-popover');
      state.showAddColumnPopover = false; state.addColumnPopoverAnchor = null;
      state.notify('showAddColumnPopover');
      if (addColumnAnchor) requestAnimationFrame(() => addColumnAnchor.focus());
      break;
    case 'add-column-from-popover':
      const columnToAdd = target.dataset.columnToAdd;
      if (columnToAdd && !state.visibleColumns.includes(columnToAdd)) {
          state.visibleColumns = [...state.visibleColumns, columnToAdd];
          state.notify('visibleColumns');
      }
      break;
    case 'reset-view':
      state.searchQuery = '';
      const searchBoxReset = document.getElementById('json-browser-search-box');
      if (searchBoxReset) searchBoxReset.value = '';
      state.searchResults = []; state.currentSearchIndex = -1;
      lastExecutedSearchQuery = null; 
      state.sortBy = null; state.sortDirection = 'asc'; state.expandedPaths.clear();

      let resetToColumns = [];
      if (robustParseCSV.lastHeaders && robustParseCSV.lastHeaders.length > 0 && robustParseCSV.lastHeaders.some(h => h && h.trim() !== '')) {
          resetToColumns = robustParseCSV.lastHeaders.filter(h => h && h.trim() !== '');
      }
      else if (state.data.length > 0 && state.data[0] && typeof state.data[0] === 'object' && state.data[0] !== null) {
          resetToColumns = Object.keys(state.data[0]);
      }
      state.visibleColumns = [...resetToColumns];
      updateAllPossibleColumns();
      state.notify('viewReset');
      break;
    case 'show-csv':
      state.csvOutputContent = generateCSV(); state.showCsvModal = true;
      state.notify('showCsvModal');
      break;
    case 'close-csv':
      closeModalFocus('.modal[aria-labelledby="csv-modal-title"]');
      state.showCsvModal = false;
      state.notify('showCsvModal');
      break;
    case 'copy-csv':
      {
        const csvOutputArea = document.getElementById('csv-output-area');
        if (csvOutputArea) {
          navigator.clipboard.writeText(csvOutputArea.value).then(() => {
            target.textContent = 'Copied!'; setTimeout(() => { target.textContent = 'Copy CSV'; }, 2000);
          }).catch(err => {
            console.error('Failed to copy CSV: ', err);
            target.textContent = 'Failed!'; setTimeout(() => { target.textContent = 'Copy CSV'; }, 2000);
          });
        }
      }
      break;
    case 'download-csv':
      {
        const blob = new Blob([state.csvOutputContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        if (link.download !== undefined) {
          const url = URL.createObjectURL(blob);
          link.setAttribute("href", url); link.setAttribute("download", "export.csv");
          link.style.visibility = 'hidden'; document.body.appendChild(link);
          link.click(); document.body.removeChild(link); URL.revokeObjectURL(url);
        } else {
          alert("CSV download not supported. Please use 'Copy CSV'.");
        }
      }
      break;

  }
};

const init = async () => {
  try {
    let rawDataInput; let dataSuccessfullyLoaded = false;
    robustParseCSV.lastHeaders = [];
    if (typeof window.jsonData !== 'undefined') {
        rawDataInput = window.jsonData;
        console.log("Global `jsonData` found and used.");
    } else {
        rawDataInput = null;
        console.log("Global `jsonData` not found.");
    }

    if (rawDataInput !== null) {
      if (Array.isArray(rawDataInput)) {
          state.data = rawDataInput; dataSuccessfullyLoaded = true;
      } else if (typeof rawDataInput === 'string') {
          try {
              const parsedJsonAttempt = JSON.parse(rawDataInput);
              if (Array.isArray(parsedJsonAttempt)) state.data = parsedJsonAttempt;
              else if (typeof parsedJsonAttempt === 'object' && parsedJsonAttempt !== null) state.data = [parsedJsonAttempt];
              else { // If not array or object, try CSV/TSV (e.g. if it's just a string "foo" which is valid JSON)
                  const delimiter = detectDelimiter(rawDataInput.substring(0, Math.min(rawDataInput.length, 2000)));
                  state.data = robustParseCSV(rawDataInput, delimiter);
              }
              dataSuccessfullyLoaded = true;
          } catch (e) {
              console.warn("Initial data (string) parsing as JSON failed, trying CSV/TSV.", e);
              const delimiter = detectDelimiter(rawDataInput.substring(0, Math.min(rawDataInput.length, 2000)));
              state.data = robustParseCSV(rawDataInput, delimiter); // robustParseCSV handles empty/malformed
              dataSuccessfullyLoaded = true;
          }
      } else if (typeof rawDataInput === 'object' && rawDataInput !== null) {
          state.data = [rawDataInput]; dataSuccessfullyLoaded = true;
      }
    }
    if (!dataSuccessfullyLoaded || !Array.isArray(state.data)) state.data = [];

    let initialVisible = [];
    if (robustParseCSV.lastHeaders && robustParseCSV.lastHeaders.length > 0 && robustParseCSV.lastHeaders.some(h => h && h.trim() !== '')) {
        initialVisible = robustParseCSV.lastHeaders.filter(h => h && h.trim() !== '');
    } else if (state.data.length > 0 && typeof state.data[0] === 'object' && state.data[0] !== null) {
        initialVisible = Object.keys(state.data[0]);
    }
    state.visibleColumns = initialVisible;
    updateAllPossibleColumns();

    if (state.data.length === 0 && typeof window.jsonData === 'undefined') {
      state.showJsonModal = true; state.rawJsonEditContent = '';
      state.jsonValidationMessage = 'Paste JSON, CSV, or TSV data, or load from file.';
    }

    state.subscribe((changedProperty) => {
        const wasSqlModalVisible = !!document.querySelector('.modal[aria-labelledby="sql-modal-title"]');
        const wasJsonModalVisible = !!document.querySelector('.modal[aria-labelledby="json-modal-title"]');
        const wasCsvModalVisible = !!document.querySelector('.modal[aria-labelledby="csv-modal-title"]');
        const wasAddColumnPopoverVisible = !!document.getElementById('add-column-popover'); // Check actual element existence
        const wasPromotePopoverVisible = !!document.getElementById('promote-key-popover'); // Check actual element existence
        
        render();

        if (state.showSqlModal && !wasSqlModalVisible) openModalFocus('.modal[aria-labelledby="sql-modal-title"]');
        if (state.showJsonModal && !wasJsonModalVisible) {
            const jsonModal = document.querySelector('.modal[aria-labelledby="json-modal-title"]');
            // Only focus if the modal itself or one of its children doesn't already have focus
            if (!jsonModal || !jsonModal.contains(document.activeElement)) {
                openModalFocus('.modal[aria-labelledby="json-modal-title"]');
            }
        }
        if (state.showCsvModal && !wasCsvModalVisible) openModalFocus('.modal[aria-labelledby="csv-modal-title"]');
        // For popovers, focus logic is often tied to their anchor or first focusable element within.
        // openModalFocus for popovers should be called after they are rendered and visible.
        if (state.showAddColumnPopover && !wasAddColumnPopoverVisible) {
             requestAnimationFrame(() => openModalFocus('#add-column-popover'));
        }
        if (state.showPromoteKeyPopover && !wasPromotePopoverVisible) {
            requestAnimationFrame(() => openModalFocus('#promote-key-popover'));
        }
    });

    document.addEventListener('click', handleEvent);
    document.addEventListener('input', (e) => {
      const target = e.target;
      if (target.id === 'json-browser-search-box') {
          handleEvent(e); 
      } else if (target.id === 'json-edit-area') {
          if (state.rawJsonEditContent !== target.value) {
              state.rawJsonEditContent = target.value;
          }
          // Clear validation message on input if it's an error/success message or initial prompt
          if (state.jsonValidationMessage && (state.jsonValidationMessage.includes('color: red') || state.jsonValidationMessage.includes('color: green') || state.jsonValidationMessage.startsWith("Paste") || state.jsonValidationMessage.startsWith("File loaded") || state.jsonValidationMessage.startsWith("File dropped"))) {
              state.jsonValidationMessage = ''; // Just clear, don't notify yet, render will pick it up or further actions.
              state.notify('jsonValidationMessage'); // Explicitly notify to clear message from UI
          }
      }
    });
    document.addEventListener('change', (e) => {
      const target = e.target;
      if (target?.dataset?.action === "change-dialect") handleEvent(e);
      else if (target.id === 'json-file-input' && target.files) {
          const file = target.files[0];
          if (file) {
              const reader = new FileReader();
              reader.onload = (loadEvent) => {
                  if (loadEvent.target && typeof loadEvent.target.result === 'string') {
                      state.rawJsonEditContent = loadEvent.target.result;
                      state.jsonValidationMessage = 'File loaded. Validate JSON or Apply & Close.';
                       // Notify both raw content and validation message to ensure UI updates
                      state.notify('rawJsonEditContent');
                      state.notify('jsonValidationMessage'); 
                  } else {
                      state.jsonValidationMessage = '<span style="color: red;">Error: Could not read file content.</span>';
                      state.notify('jsonValidationMessage');
                  }
                  target.value = ''; // Reset file input
              };
              reader.onerror = () => {
                  state.jsonValidationMessage = '<span style="color: red;">Error reading file.</span>';
                  state.notify('jsonValidationMessage');
                  target.value = ''; // Reset file input
              };
              reader.readAsText(file);
          }
      }
    });
    document.addEventListener('keydown', handleKeyboard); 
    render(); 
  } catch (error) {
    console.error('Initialization error:', error);
    const appElement = document.getElementById('app');
    if (appElement) appElement.innerHTML = `<div class="no-results" style="color: red; border: 1px solid red; padding: 20px;">Initialization Error: ${error.message}<br><pre>${error.stack}</pre></div>`;
  }
};

if (typeof window.jsonData === 'undefined' && (document.readyState === 'loading' || document.readyState === 'interactive')) {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}
// --- END OF INLINED basic.js (entry point) ---

</script>
</body>
</html>