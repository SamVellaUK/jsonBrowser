import { resolvePath, promoteField, applyActiveColumns } from './render.js';

export function setupUIListeners() {
  // Expand All Button
  const expandAllButton = document.getElementById('expand-all');
  if (!expandAllButton) {
    console.error('Error: Element with id "expand-all" not found');
    return;
  }
  expandAllButton.onclick = () => {
    document.querySelectorAll('.nested-content').forEach(div => div.style.display = 'block');
    document.querySelectorAll('.toggle-nest').forEach(span => span.textContent = '[-]');
  };

  // Collapse All Button
  const collapseAllButton = document.getElementById('collapse-all');
  if (!collapseAllButton) {
    console.error('Error: Element with id "collapse-all" not found');
    return;
  }
  collapseAllButton.onclick = () => {
    document.querySelectorAll('.nested-content').forEach(div => div.style.display = 'none');
    document.querySelectorAll('.toggle-nest').forEach(span => span.textContent = '[+]');
  };

  // Edit Mode Button
  const editModeButton = document.getElementById('edit-mode');
  if (!editModeButton) {
    console.error('Error: Element with id "edit-mode" not found');
    return;
  }
  editModeButton.onclick = function () {
    window.editMode = !window.editMode;
    this.classList.toggle('active');
    document.querySelectorAll('.promote-button').forEach(btn => {
      btn.style.display = window.editMode ? 'inline' : 'none';
    });
    console.log('Edit mode:', window.editMode);
  };

  // Show JSON Paths Button
  const showJsonPathsButton = document.getElementById('show-json-paths');
  if (!showJsonPathsButton) {
    console.error('Error: Element with id "show-json-paths" not found');
    return;
  }
  showJsonPathsButton.onclick = function () {
    window.showJsonPaths = !window.showJsonPaths;
    this.classList.toggle('active');
    document.querySelectorAll('.json-path').forEach(p => {
      p.style.display = window.showJsonPaths ? 'block' : 'none';
    });
    console.log('Show JSON Paths:', window.showJsonPaths);
  };

  // Column Chooser Button
  const columnChooserButton = document.getElementById('column-chooser-button');
  if (!columnChooserButton) {
    console.error('Error: Element with id "column-chooser-button" not found');
    return;
  }
  columnChooserButton.onclick = function () {
    const columnChooser = document.getElementById('column-chooser');
    if (!columnChooser) {
      console.error('Error: Element with id "column-chooser" not found');
      return;
    }
    const isVisible = columnChooser.style.display === 'block';
    columnChooser.style.display = isVisible ? 'none' : 'block';
    console.log('Column chooser visibility:', !isVisible);
  };

  // Close Column Chooser Button
  const closeColumnChooserButton = document.getElementById('close-column-chooser');
  if (closeColumnChooserButton) {
    closeColumnChooserButton.onclick = function () {
      const columnChooser = document.getElementById('column-chooser');
      if (columnChooser) {
        columnChooser.style.display = 'none';
        console.log('Column chooser closed');
      }
    };
  }

// Apply Changes button inside Column Chooser
const applyButton = document.getElementById('apply-columns');
if (applyButton) {
  applyButton.addEventListener('click', async () => {
    applyButton.disabled = true;
    applyButton.textContent = 'Applying...';

    await applyActiveColumns(); // ensure applyActiveColumns is async if needed

    applyButton.disabled = false;
    applyButton.textContent = 'Apply Changes';
  });
}

// Close Column Chooser on ESC Key
document.addEventListener('keydown', (event) => {
  if (event.key === 'Escape') {
    const columnChooser = document.getElementById('column-chooser');
    if (columnChooser && columnChooser.style.display === 'block') {
      columnChooser.style.display = 'none';
      console.log('Column chooser closed (ESC key)');
    }
  }
});

// 🔍 Search Button
const searchButton = document.getElementById('search-button');
const searchBox = document.getElementById('search-box');

if (searchButton && searchBox) {
  searchButton.onclick = () => {
    const query = searchBox.value.trim();
    performSearch(query); // Always call, even if query is empty
  };

  searchBox.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      const query = searchBox.value.trim();
      performSearch(query); // Always call
    }
  });
}

// 🔁 Next/Prev Buttons
const searchNext = document.getElementById('search-next');
const searchPrev = document.getElementById('search-prev');
if (searchNext) {
  searchNext.onclick = () => navigateSearch('next');
}
if (searchPrev) {
  searchPrev.onclick = () => navigateSearch('prev');
}

}

function performSearch(query) {
  clearPreviousSearch();

  const matches = [];
  const lowerQuery = query.trim().toLowerCase();

  if (!lowerQuery) {
    console.log('🔎 Empty query — nothing to search');
    return;
  }

  function walk(obj, path = '', rowIndex = null) {
    if (obj === null || obj === undefined) return;

    if (typeof obj === 'object') {
      if (Array.isArray(obj)) {
        obj.forEach((item, i) => walk(item, `[${i}]`, i));
      } else {
        Object.entries(obj).forEach(([key, value]) => {
          const newPath = path ? `${path}.${key}` : key;
          walk(value, newPath, rowIndex);
        });
      }
    } else {
      const valStr = String(obj);
      if (valStr.toLowerCase().includes(lowerQuery)) {
        matches.push({ path, value: valStr });
      }
    }
  }

  walk(window.DATA);

  window.searchMatches = matches;
  window.highlightedPaths = new Set(matches.map(m => m.path));
  window.currentSearchIndex = matches.length > 0 ? 0 : -1;
  window.activeMatchPath = matches[window.currentSearchIndex]?.path || null;

  console.log(`🔎 Found ${matches.length} matches`);
  updateSearchCounter();

  applyActiveColumns(); // Or trigger your table re-render
}



export function clearPreviousSearch() {
  const highlighted = document.querySelectorAll('.highlight, .highlight-active');

  highlighted.forEach(span => {
    const parent = span.parentNode;
    if (!parent) return;

    // Move all children of the span back into the parent
    while (span.firstChild) {
      parent.insertBefore(span.firstChild, span);
    }

    // Remove the now-empty span
    parent.removeChild(span);
  });

  window.searchMatches = [];
  window.currentSearchIndex = -1;
  updateSearchCounter();
}


export function updateSearchCounter() {
  const counter = document.getElementById('search-counter');
  if (!counter) return;

  const total = window.searchMatches.length;
  const current = total > 0 ? window.currentSearchIndex + 1 : 0;

  let counterText = `${current} of ${total}`;

  const visibleColumnPaths = window.columnState.order || [];

  const hiddenMatches = window.searchMatches.filter(match => {
    if (!match.path) return false;

    // Strip array index prefix like "[5]." → becomes "event_name"
    const normalizedPath = match.path.replace(/^\[\d+\]\./, '');

    const isVisible = visibleColumnPaths.some(visiblePath =>
      normalizedPath === visiblePath || normalizedPath.startsWith(visiblePath + '.')
    );

    return !isVisible;
  });


  if (hiddenMatches.length > 0) {
    counterText += ` <span style="color: red; font-size: 10px; margin-left: 8px;">${hiddenMatches.length} hidden</span>`;
  }

  counter.innerHTML = counterText;
}




function navigateSearch(direction) {
  console.log('[navigate] Not yet implemented — direction:', direction);
  // Placeholder logic for Version 9.2
}


export function highlightRow(row) {
  // Remove highlight from all rows
  const table = row.closest('table');
  if (table) {
    table.querySelectorAll('tr').forEach((tr) => tr.classList.remove('highlighted'));
  }

  // Add highlight to the clicked row
  row.classList.add('highlighted');
}

export function sortTableByColumn(table, columnIndex, asc = true) {
  const tbody = table.tBodies[0];
  const rowsArray = Array.from(tbody.querySelectorAll('tr'))
    .filter(row => row.closest('table') === table); // Only top-level rows

  rowsArray.sort((rowA, rowB) => {
    let cellA = rowA.cells[columnIndex];
    let cellB = rowB.cells[columnIndex];

    if (!cellA || !cellB) return 0;

    cellA = cellA.innerText.trim();
    cellB = cellB.innerText.trim();

    const numA = parseFloat(cellA);
    const numB = parseFloat(cellB);
    const isNumeric = !isNaN(numA) && !isNaN(numB);

    if (isNumeric) {
      return asc ? numA - numB : numB - numA;
    } else {
      return asc ? cellA.localeCompare(cellB) : cellB.localeCompare(cellA);
    }
  });

  rowsArray.forEach(row => tbody.appendChild(row));
}

