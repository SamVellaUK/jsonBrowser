import { highlightRow } from './ui.js';
import { sortTableByColumn } from './ui.js';

export function renderTable(data) {
  const tableContainer = document.getElementById('table-container');
  if (!tableContainer) {
    console.error('Error: #table-container element not found');
    return;
  }

  tableContainer.innerHTML = ''; // Clear the table container before rendering

  if (!Array.isArray(data) || data.length === 0) {
    tableContainer.textContent = 'No data available to display.';
    return;
  }

  const MAX_SCAN_ROWS = 50;
  buildJsonStructure(data.slice(0, MAX_SCAN_ROWS));

  // Auto-populate columnState with top-level fields (if not already set)
  const topLevelFields = Object.keys(window.jsonStructure || {});
  window.columnState = {
    visibleColumns: topLevelFields.map(field => ({ path: field, label: field })),
    order: [...topLevelFields],
  };

  renderActiveColumnList();

  const table = document.createElement('table');
  table.id = 'data-table';

  const thead = document.createElement('thead');
  const headerRow = document.createElement('tr');

  const rowNumberHeader = document.createElement('th');
  rowNumberHeader.textContent = '#';
  headerRow.appendChild(rowNumberHeader);

  // Column headers
  window.columnState.order.forEach((path, index) => {
    const headerCell = document.createElement('th');
    const column = window.columnState.visibleColumns.find(col => col.path === path);
    headerCell.textContent = column ? column.label : path;
    headerCell.style.cursor = 'pointer';
    headerCell.dataset.columnIndex = index;
    headerCell.dataset.sortDirection = 'asc';

    headerCell.addEventListener('click', function () {
      const currentDir = this.dataset.sortDirection === 'asc' ? 'desc' : 'asc';
      this.dataset.sortDirection = currentDir;
      sortTableByColumn(table, parseInt(this.dataset.columnIndex), currentDir === 'asc');
    });

    headerRow.appendChild(headerCell);
  });

  thead.appendChild(headerRow);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');

  data.forEach((item, rowIndex) => {
    const row = document.createElement('tr');

    const rowNumberCell = document.createElement('td');
    rowNumberCell.className = 'row-number';
    rowNumberCell.textContent = rowIndex + 1;
    row.appendChild(rowNumberCell);

    window.columnState.order.forEach((path) => {
      const cell = document.createElement('td');
      const value = resolvePath(item, path);
      renderCell(cell, value, path, rowIndex); // ✅ pass rowIndex here
      row.appendChild(cell);
    });

    row.addEventListener('click', () => highlightRow(row));
    tbody.appendChild(row);
  });

  table.appendChild(tbody);
  tableContainer.appendChild(table);
}



export function renderColumnChooser() {
  const container = document.getElementById('available-fields');
  if (!container || !window.jsonStructure) {
    console.error('Column chooser container or jsonStructure is missing.');
    return;
  }

  // ✅ Always refresh the right-hand active list when opening
  renderActiveColumnList();

  // Clear the left-hand tree before re-rendering
  const existingElements = container.querySelectorAll('.field-tree');
  existingElements.forEach(el => el.remove());

  const treeContainer = document.createElement('div');
  treeContainer.className = 'field-tree';
  treeContainer.style.marginTop = '10px';

  buildTree(window.jsonStructure, treeContainer);  // ← Updated buildTree below

  container.appendChild(treeContainer);
}

function buildTree(structure, parentElement, path = []) {
  for (const key in structure) {
    if (key === '__leaf') continue; // Skip internal marker

    const currentPath = [...path, key].join('.');

    const wrapper = document.createElement('div');
    wrapper.className = 'field-item';
    wrapper.style.display = 'block';
    wrapper.style.marginLeft = `${path.length * 5}px`; // ← Your preferred indent

    const hasChildren = typeof structure[key] === 'object' &&
                        Object.keys(structure[key]).some(k => k !== '__leaf');

    // Toggle (+ / -)
    const toggle = document.createElement('span');
    toggle.className = 'toggle';
    toggle.textContent = hasChildren ? '−' : '';
    toggle.style.cursor = hasChildren ? 'pointer' : 'default';
    toggle.style.userSelect = 'none';
    toggle.style.marginRight = '5px';
    toggle.style.color = hasChildren ? '#007BFF' : '#000';

    // Checkbox
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.dataset.path = currentPath;
    checkbox.dataset.label = key;

    // ✅ Pre-check if the field is active in the column state
    checkbox.checked = window.columnState.order.includes(currentPath);

    // Checkbox event listener to sync state
    checkbox.addEventListener('change', (e) => {
      const fieldPath = e.target.dataset.path;
      const label = e.target.dataset.label;
      const isChecked = e.target.checked;

      if (isChecked) {
        addVisibleColumn(fieldPath, label);
      } else {
        removeVisibleColumn(fieldPath);
      }

      renderActiveColumnList(); // Refresh right-hand panel
    });

    // Label
    const label = document.createElement('label');
    label.textContent = key;
    label.style.marginLeft = '5px';

    // Checkbox → Label → Toggle (your preferred order)
    const lineContainer = document.createElement('span');
    lineContainer.style.display = 'inline-flex';
    lineContainer.style.alignItems = 'center';

    lineContainer.appendChild(checkbox);
    lineContainer.appendChild(label);
    lineContainer.appendChild(toggle);

    wrapper.appendChild(lineContainer);
    parentElement.appendChild(wrapper);

    // Handle children recursively
    if (hasChildren) {
      const childContainer = document.createElement('div');
      childContainer.className = 'child-container';
      childContainer.style.display = 'block'; // Expanded by default

      wrapper.appendChild(childContainer);
      buildTree(structure[key], childContainer, [...path, key]);

      // Toggle behavior
      toggle.addEventListener('click', () => {
        const isCollapsed = childContainer.style.display === 'none';
        childContainer.style.display = isCollapsed ? 'block' : 'none';
        toggle.textContent = isCollapsed ? '−' : '+';
      });
    }
  }
}


export function buildJsonStructure(data, maxRows = 50) {
  const structure = {};

  function walk(obj, target) {
    if (obj === null || obj === undefined) {
      return false; // Skip nulls and undefined
    }

    if (Array.isArray(obj)) {
      if (obj.length === 0) {
        return false; // Skip empty arrays
      }
      let found = false;
      obj.forEach((item) => {
        if (walk(item, target)) {
          found = true;
        }
      });
      return found;
    }

    if (typeof obj === 'object') {
      const keys = Object.keys(obj);
      if (keys.length === 0) {
        return false; // Skip empty objects
      }
      let hasChild = false;
      keys.forEach((key) => {
        if (!target[key]) target[key] = {};
        const childHasContent = walk(obj[key], target[key]);
        if (!childHasContent) {
          delete target[key];
        } else {
          hasChild = true;
        }
      });
      return hasChild;
    }

    // Primitive value: mark as a leaf node with __leaf flag
    target.__leaf = true;
    return true;
  }

  data.slice(0, maxRows).forEach((row) => {
    walk(row, structure);
  });

  window.jsonStructure = structure;
  console.log('Generated JSON Structure:', window.jsonStructure);
}
export function renderActiveColumnList() {
  const activeContainer = document.getElementById('active-columns');
  if (!activeContainer) {
    console.error('Error: #active-columns container not found.');
    return;
  }
  console.log('Rendering active columns:', window.columnState.order);

  activeContainer.innerHTML = ''; // Clear before rendering

  window.columnState.order.forEach((path) => {
    const column = window.columnState.visibleColumns.find(col => col.path === path);
    if (!column) return; // Safety check, shouldn't happen

    const row = document.createElement('div');
    row.className = 'active-column-item';
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.marginBottom = '5px';

    const label = document.createElement('span');
    label.textContent = column.label;
    label.style.flexGrow = '1';

    const upButton = document.createElement('button');
    upButton.textContent = '↑';
    upButton.style.marginRight = '5px';
    upButton.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      moveColumnUp(path);
      renderActiveColumnList();
    });

    const downButton = document.createElement('button');
    downButton.textContent = '↓';
    downButton.style.marginRight = '5px';
    downButton.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      moveColumnDown(path);
      renderActiveColumnList();
    });

    const removeButton = document.createElement('button');
    removeButton.textContent = '✖';
    removeButton.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      removeVisibleColumn(path);               // Update state
      renderActiveColumnList();                // Refresh right-hand panel
      syncTreeCheckbox(path, false);           // Uncheck the left-hand checkbox
    });

    row.appendChild(label);
    row.appendChild(upButton);
    row.appendChild(downButton);
    row.appendChild(removeButton);
    activeContainer.appendChild(row);
  });

  console.log('Finished rendering active columns:', window.columnState.order);
}


function syncTreeCheckbox(path, checked) {
  const checkbox = document.querySelector(`input[type="checkbox"][data-path="${path}"]`);
  if (checkbox) {
    checkbox.checked = checked;
  }
}


function addVisibleColumn(path, label) {
  if (!window.columnState.order.includes(path)) {
    window.columnState.visibleColumns.push({ path, label });
    window.columnState.order.push(path);
  }
}

function removeVisibleColumn(path) {
  window.columnState.visibleColumns = window.columnState.visibleColumns.filter(col => col.path !== path);
  window.columnState.order = window.columnState.order.filter(p => p !== path);
}

function moveColumnUp(path) {
  const index = window.columnState.order.indexOf(path);
  if (index > 0) {
    const order = window.columnState.order;
    [order[index - 1], order[index]] = [order[index], order[index - 1]];
  }
}

function moveColumnDown(path) {
  const index = window.columnState.order.indexOf(path);
  if (index >= 0 && index < window.columnState.order.length - 1) {
    const order = window.columnState.order;
    [order[index], order[index + 1]] = [order[index + 1], order[index]];
  }
}


// In renderCell(container, value, path)
export function renderCell(container, value, path = '', rowIndex = null) {
  const fullPath = `[${rowIndex}].${path}`;

  if (typeof value === 'object' && value !== null) {
    const toggle = document.createElement('span');
    toggle.textContent = '[+]';
    toggle.className = 'toggle-nest';

    const nestedDiv = document.createElement('div');
    nestedDiv.className = 'nested-content';
    nestedDiv.style.display = 'none';

    toggle.onclick = () => {
      const isHidden = nestedDiv.style.display === 'none';
      nestedDiv.style.display = isHidden ? 'block' : 'none';
      toggle.textContent = isHidden ? '[-]' : '[+]';
    
      if (isHidden && nestedDiv.childElementCount === 0) {
        const relativePath = path.replace(/^\[\d+\]\./, '');
        const nestedValue = resolvePath(window.DATA[rowIndex], relativePath);
    
        if (!nestedValue || typeof nestedValue !== 'object') {
          console.warn(`⚠️ Cannot expand: invalid nested value at ${relativePath}`);
          return;
        }
    
        const nestedTable = renderNested(nestedValue, path, rowIndex); // Keep full path for tracking
        nestedDiv.appendChild(nestedTable);
      }
    };
    

    container.appendChild(toggle);
    container.appendChild(document.createTextNode(Array.isArray(value) ? '[...]' : '{...}'));
    container.appendChild(nestedDiv);
  } else {
    const valueSpan = document.createElement('span');
    valueSpan.textContent = value !== undefined ? value : '';
    valueSpan.setAttribute('data-path', fullPath);

    if (window.highlightedPaths?.has(fullPath)) {
      valueSpan.classList.add('highlight');
      if (fullPath === window.activeMatchPath) {
        valueSpan.classList.add('highlight-active');
      }
    }

    container.appendChild(valueSpan);
  }
}

export function renderNested(obj, parentPath = '', rowIndex = null) {
  if (!obj || typeof obj !== 'object') {
    console.warn(`⚠️ Invalid nested object at ${parentPath}`);
    return document.createTextNode('[invalid]');
  }

  const table = document.createElement('table');
  table.className = 'nested-table';
  const tbody = document.createElement('tbody');

  Object.entries(obj).forEach(([key, val]) => {
    const tr = document.createElement('tr');
    const tdKey = document.createElement('td');
    const relativePath = parentPath ? `${parentPath}.${key}` : key;

    tdKey.textContent = key;
    tdKey.setAttribute('data-path', relativePath);

    if (window.highlightedPaths?.has(relativePath)) {
      tdKey.classList.add('highlight');
      if (relativePath === window.activeMatchPath) {
        tdKey.classList.add('highlight-active');
      }
    }

    const tdVal = document.createElement('td');
    tdVal.setAttribute('data-path', relativePath);

    if (typeof val === 'object' && val !== null) {
      const toggle = document.createElement('span');
      toggle.textContent = '[+]';
      toggle.className = 'toggle-nest';

      const nestedDiv = document.createElement('div');
      nestedDiv.className = 'nested-content';
      nestedDiv.style.display = 'none';

      toggle.onclick = () => {
        const isHidden = nestedDiv.style.display === 'none';
        nestedDiv.style.display = isHidden ? 'block' : 'none';
        toggle.textContent = isHidden ? '[-]' : '[+]';
      
        if (isHidden && nestedDiv.childElementCount === 0) {
          const relativePath = displayPath.replace(/^\[\d+\]\./, '');
          const nestedVal = resolvePath(window.DATA[rowIndex], relativePath);
      
          if (!nestedVal || typeof nestedVal !== 'object') {
            console.warn(`⚠️ Invalid nested value at ${relativePath}`);
            return;
          }
      
          const nestedTable = renderNested(nestedVal, displayPath, rowIndex);
          nestedDiv.appendChild(nestedTable);
        }
      };
      

      tdVal.appendChild(toggle);
      tdVal.appendChild(document.createTextNode(Array.isArray(val) ? '[...]' : '{...}'));
      tdVal.appendChild(nestedDiv);
    } else {
      renderCell(tdVal, val, relativePath.replace(/^\[\d+\]\./, ''), rowIndex);
    }

    const promoteButton = document.createElement('span');
    promoteButton.textContent = '+';
    promoteButton.className = 'promote-button';
    promoteButton.style.display = window.editMode ? 'inline' : 'none';
    promoteButton.onclick = () => promoteField(relativePath, key);
    tdKey.appendChild(promoteButton);

    tr.appendChild(tdKey);
    tr.appendChild(tdVal);
    tbody.appendChild(tr);
  });

  table.appendChild(tbody);
  return table;
}


export function resolvePath(obj, path) {
  return path.split('.').reduce((acc, key) => {
    const match = key.match(/^(\w+)\[(\d+)\]$/);
    if (match) {
      const [, arrayKey, index] = match;
      return acc?.[arrayKey]?.[index];
    }
    return acc?.[key];
  }, obj);
}

export function promoteField(path, columnName) {
  const table = document.getElementById('data-table'); // Ensure we are working with the base table
  if (!table) {
    console.error('Base table (data-table) not found.');
    return;
  }

  console.log(`Promoting field with path: ${path} and column name: ${columnName}`);

  const headers = table.querySelector('thead tr');
  //const bodyRows = table.querySelectorAll('tbody > tr'); // Ensure only direct child rows are selected
   
  console.log(`Check if column exists`)
 
  
  if (!headers) {
    console.error('Table header row not found.');
    return;
  }
  // Check if column already exists
  if (Array.from(headers.children).some(th => th.textContent === columnName)) {
    console.warn(`Column "${columnName}" already exists.`);
    return;
  }
  console.log(`Column "${columnName}" does not exist, proceeding to add it.`);
  // Add new column header
  const newHeader = document.createElement('th');
  newHeader.textContent = columnName;
  newHeader.style.cursor = 'pointer';
  const columnIndex = headers.children.length;
  newHeader.dataset.columnIndex = columnIndex;
  newHeader.dataset.sortDirection = 'asc';
  
  newHeader.addEventListener('click', function () {
    const currentDir = this.dataset.sortDirection === 'asc' ? 'desc' : 'asc';
    this.dataset.sortDirection = currentDir;
    const table = document.getElementById('data-table');
    sortTableByColumn(table, columnIndex, currentDir === 'asc');
  });
  // ✅ Don't forget this!
headers.appendChild(newHeader);

  console.log(`Added new header for column: ${columnName}`);

  // Add new column cells
  const bodyRows = table.querySelectorAll(':scope > tbody > tr');
  if (!bodyRows.length) {
    console.error('No body rows found in the table.');
    return;
  }
  bodyRows.forEach((row, rowIndex) => {
    console.log(`Adding cell to row ${rowIndex}`);
    const newCell = document.createElement('td');
    newCell.setAttribute('data-column-index', headers.children.length - 1);
  
    const fullPath = path.startsWith('raw_event.') ? path : `raw_event.${path}`;
    const value = resolvePath(window.DATA[rowIndex], fullPath);
  
    newCell.textContent = value !== undefined ? value : '';
    row.appendChild(newCell);
  });

  console.log(`Promoted field "${columnName}" to base table.`);

  addVisibleColumn(path, columnName);
  renderActiveColumnList();
}

export function applyActiveColumns() {
  const tableContainer = document.getElementById('table-container');
  if (!tableContainer) {
    console.error('Error: #table-container element not found.');
    return;
  }

  const data = window.DATA;  // <-- Assuming your full dataset is stored here
  if (!Array.isArray(data) || data.length === 0) {
    tableContainer.textContent = 'No data available to display.';
    return;
  }

  tableContainer.innerHTML = ''; // Clear previous table

  const table = document.createElement('table');
  table.id = 'data-table';
  const thead = document.createElement('thead');
  const headerRow = document.createElement('tr');

  // Row number column
  const rowNumberHeader = document.createElement('th');
  rowNumberHeader.textContent = '#';
  headerRow.appendChild(rowNumberHeader);

  // Create headers from active columns
  window.columnState.order.forEach((path, index) => {
    const headerCell = document.createElement('th');
    const column = window.columnState.visibleColumns.find(col => col.path === path);
    headerCell.textContent = column ? column.label : path; // fallback if no label
    headerCell.style.cursor = 'pointer';
    headerCell.dataset.columnIndex = index;
    headerCell.dataset.sortDirection = 'asc';

    headerCell.addEventListener('click', function () {
      const currentDir = this.dataset.sortDirection === 'asc' ? 'desc' : 'asc';
      this.dataset.sortDirection = currentDir;
      sortTableByColumn(table, parseInt(this.dataset.columnIndex), currentDir === 'asc');
    });

    headerRow.appendChild(headerCell);
  });

  thead.appendChild(headerRow);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');

  data.forEach((item, rowIndex) => {
    const row = document.createElement('tr');

    const rowNumberCell = document.createElement('td');
    rowNumberCell.className = 'row-number';
    rowNumberCell.textContent = rowIndex + 1;
    row.appendChild(rowNumberCell);

    window.columnState.order.forEach((path) => {
      const cell = document.createElement('td');
      const value = resolvePath(item, path);
      renderCell(cell, value, path);
      row.appendChild(cell);
    });

    row.addEventListener('click', () => highlightRow(row));
    tbody.appendChild(row);
  });

  table.appendChild(tbody);
  tableContainer.appendChild(table);
}
