<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>JSON Explorer (Nested)</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="top-menu">
    <button onclick="fetchJSON()">Refresh</button>
    <button id="expand-all">Expand All</button>
    <button id="collapse-all">Collapse All</button>
    <button id="toggle-json-paths">Show JSON Paths</button>
    <button id="edit-mode" class="edit-button">Edit</button> <!-- Added Edit button -->
  </div>

  <div id="json-root"></div>

  <script>
    let DATA = [];
    let editMode = false; // Global flag for Edit mode

    async function fetchJSON() {
      try {
        const response = await fetch("./JSON Output/samplejson.json");
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        DATA = await response.json();
        renderTable(DATA);
      } catch (error) {
        console.error('Failed to load JSON:', error);
        document.getElementById('json-root').textContent = 'Failed to load JSON data.';
      }
    }

    function renderTable(data) {
      const root = document.getElementById('json-root');
      root.innerHTML = '';
      if (!Array.isArray(data) || data.length === 0) {
        root.textContent = 'No data available.';
        return;
      }

      const table = document.createElement('table');
      table.id = 'data-table';
      const thead = document.createElement('thead');
      const tbody = document.createElement('tbody');

      const headers = Object.keys(data[0]);
      const headerRow = document.createElement('tr');

      const thIndex = document.createElement('th');
      thIndex.textContent = '#';
      headerRow.appendChild(thIndex);

      headers.forEach((header, idx) => {
        const th = document.createElement('th');
        th.textContent = header;
        th.setAttribute('data-column-index', idx + 1);
        th.setAttribute('data-sort-dir', 'desc');
        th.onclick = () => sortColumn(idx + 1);
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);

      data.forEach((row, rowIndex) => {
        const tr = document.createElement('tr');
        tr.setAttribute('onclick', 'highlightRow(this)');

        const tdIndex = document.createElement('td');
        tdIndex.className = 'row-number';
        tdIndex.textContent = rowIndex + 1;
        tr.appendChild(tdIndex);

        headers.forEach((header, idx) => {
          const td = document.createElement('td');
          td.setAttribute('data-column-index', idx + 1);
          // Do not show JSON paths for top-level elements
          renderCell(td, row[header], '');
          tr.appendChild(td);
        });

        tbody.appendChild(tr);
      });

      table.appendChild(thead);
      table.appendChild(tbody);
      root.appendChild(table);
    }

    function renderCell(container, value, path = '') {
      if (typeof value === 'object' && value !== null) {
        const toggle = document.createElement('span');
        toggle.textContent = '[+]';
        toggle.className = 'toggle-nest';

        const nestedDiv = document.createElement('div');
        nestedDiv.className = 'nested-content';
        nestedDiv.style.display = 'none';

        toggle.addEventListener('click', () => {
          const isHidden = nestedDiv.style.display === 'none';
          nestedDiv.style.display = isHidden ? 'block' : 'none';
          toggle.textContent = isHidden ? '[-]' : '[+]';
        });

        container.appendChild(toggle);
        container.appendChild(document.createTextNode(Array.isArray(value) ? '[...]' : '{...}'));
        container.appendChild(nestedDiv);

        nestedDiv.appendChild(renderNested(value, path));
      } else {
        const wrapper = document.createElement('div');
        wrapper.style.display = 'flex';
        wrapper.style.alignItems = 'center';
        wrapper.style.justifyContent = 'space-between';

        const valueSpan = document.createElement('span');
        valueSpan.textContent = value;

        wrapper.appendChild(valueSpan); // Ensure valueSpan is appended to the wrapper

        // Remove promote button logic for value cells
        container.appendChild(wrapper); // Append the wrapper to the container
      }
    }

    function renderNested(obj, parentPath = '') {
      const table = document.createElement('table');
      table.className = 'nested-table';
      const tbody = document.createElement('tbody');

      if (Array.isArray(obj)) {
        obj.forEach((item, i) => {
          const tr = document.createElement('tr');
          const tdKey = document.createElement('td');
          tdKey.textContent = i;

          const tdVal = document.createElement('td');
          renderCell(tdVal, item, parentPath ? `${parentPath}[${i}]` : '');
          tr.appendChild(tdKey);
          tr.appendChild(tdVal);
          tbody.appendChild(tr);
        });
      } else {
        Object.entries(obj).forEach(([key, val]) => {
          const tr = document.createElement('tr');
          const tdKey = document.createElement('td');
          tdKey.className = 'key';

          // Add key name
          const keySpan = document.createElement('span');
          keySpan.textContent = key;
          tdKey.appendChild(keySpan);

          // Add promote button in Edit mode
          const promoteButton = document.createElement('span');
          promoteButton.textContent = '+';
          promoteButton.className = 'promote-button';
          promoteButton.style.display = editMode ? 'inline' : 'none';
          promoteButton.addEventListener('click', () => {
            const fullPath = parentPath ? `${parentPath}.${key}` : key;
            console.log('Promote field:', fullPath); // Extract and log the full path
            const columnName = key; // Use the last segment of the path as the column name
            promoteField(fullPath, columnName);
          });

          tdKey.appendChild(promoteButton);

          // Add JSON path
          const jsonPath = document.createElement('div');
          jsonPath.className = 'json-path';
          jsonPath.style.display = 'none';
          jsonPath.textContent = parentPath ? `${parentPath}.${key}` : key;
          tdKey.appendChild(document.createElement('br')); // Add a line break
          tdKey.appendChild(jsonPath);

          const tdVal = document.createElement('td');
          renderCell(tdVal, val, parentPath ? `${parentPath}.${key}` : key);
          tr.appendChild(tdKey);
          tr.appendChild(tdVal);
          tbody.appendChild(tr);
        });
      }
      table.appendChild(tbody);
      return table;
    }

    function sortColumn(index) {
      const table = document.getElementById('data-table');
      const rows = Array.from(table.rows).slice(1);
      const header = table.querySelector(`th[data-column-index='${index}']`);
      const sortDir = header.getAttribute('data-sort-dir') === 'asc' ? 'desc' : 'asc';
      header.setAttribute('data-sort-dir', sortDir);

      rows.sort((rowA, rowB) => {
        const cellA = rowA.cells[index].innerText;
        const cellB = rowB.cells[index].innerText;
        if (!isNaN(cellA) && !isNaN(cellB)) {
          return sortDir === 'asc' ? cellA - cellB : cellB - cellA;
        }
        return sortDir === 'asc' ? cellA.localeCompare(cellB) : cellB.localeCompare(cellA);
      });

      rows.forEach((row, i) => {
        row.cells[0].innerText = i + 1;
        table.appendChild(row);
      });
    }

    function highlightRow(row) {
      const table = row.closest('table');
      if (table && table.id === 'data-table') {
        const highlighted = document.querySelectorAll('#data-table .highlighted');
        highlighted.forEach(item => item.classList.remove('highlighted'));
        row.classList.add('highlighted');
      }
    }

    function promoteField(fullPath, columnName) {
      const table = document.getElementById('data-table');
      const headers = table.querySelector('thead tr');
      const bodyRows = table.querySelectorAll('tbody tr');

      // Check if column already exists
      if (Array.from(headers.children).some(th => th.textContent === columnName)) {
        console.warn(`Column "${columnName}" already exists.`);
        return;
      }

      // Add new column header
      const newHeader = document.createElement('th');
      newHeader.textContent = columnName;
      newHeader.setAttribute('data-column-index', headers.children.length);
      newHeader.setAttribute('data-sort-dir', 'desc');
      newHeader.onclick = () => sortColumn(headers.children.length);
      headers.appendChild(newHeader);

      // Add new column cells
      bodyRows.forEach((row, rowIndex) => {
        const newCell = document.createElement('td');
        newCell.setAttribute('data-column-index', headers.children.length);

        // Resolve value from the full path
        const value = resolvePath(DATA[rowIndex], fullPath);
        newCell.textContent = value !== undefined ? value : ''; // Empty if value doesn't exist
        row.appendChild(newCell);
      });
    }

    function resolvePath(obj, path) {
      return path.split('.').reduce((acc, key) => {
        // Handle array indices in paths
        const match = key.match(/^(\w+)\[(\d+)\]$/);
        if (match) {
          const [, arrayKey, index] = match;
          return acc && acc[arrayKey] && Array.isArray(acc[arrayKey]) ? acc[arrayKey][index] : undefined;
        }
        return acc && acc[key] !== undefined ? acc[key] : undefined;
      }, obj);
    }

    document.getElementById('expand-all').addEventListener('click', () => {
      document.querySelectorAll('.nested-content').forEach(div => {
        div.style.display = 'block';
      });
      document.querySelectorAll('.toggle-nest').forEach(span => {
        span.textContent = '[-]';
      });
    });

    document.getElementById('collapse-all').addEventListener('click', () => {
      document.querySelectorAll('.nested-content').forEach(div => {
        div.style.display = 'none';
      });
      document.querySelectorAll('.toggle-nest').forEach(span => {
        span.textContent = '[+]';
      });
    });

    document.getElementById('toggle-json-paths').addEventListener('click', () => {
      const paths = document.querySelectorAll('.json-path');
      const isVisible = paths[0]?.style.display !== 'none';
      paths.forEach(p => p.style.display = isVisible ? 'none' : 'inline');
      document.getElementById('toggle-json-paths').textContent = isVisible ? 'Show JSON Paths' : 'Hide JSON Paths';
    });

    document.getElementById('edit-mode').addEventListener('click', function () {
      this.classList.toggle('active'); // Toggle active state
      editMode = !editMode; // Toggle the global editMode flag

      // Show/hide promote buttons based on Edit mode
      document.querySelectorAll('.promote-button').forEach(button => {
        button.style.display = editMode ? 'inline' : 'none';
      });

      console.log('Edit mode:', editMode); // Debugging log
    });

    fetchJSON();
  </script>
</body>
</html>
