<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Structured Data Browser</title>
<style>
/* --- START OF FILE basic.css --- */

/* =============================================
   Global & Body Styles
   ============================================= */
* { 
  box-sizing: border-box; 
}

body { 
  font-family: 'Consolas', monospace; 
  margin: 0; 
  padding: 20px;
  background: #f8f9fa;
  /* overflow: hidden;  REMOVED FOR ACCESSIBILITY */
}

/* =============================================
   Layout & Main Containers
   ============================================= */

/* Header Area */
.header { 
  position: sticky; 
  top: 0;
  background: #fff;
  padding: 15px;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  margin-bottom: 20px;
  display: flex;
  gap: 15px;
  align-items: center;
  flex-wrap: wrap;
  z-index: 200; 
}

/* Scrollable viewport for the main table */
.json-table { 
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  max-height: calc(100vh - 140px); 
  overflow-y: auto; 
  overflow-x: auto; /* <<<< THIS IS KEY */
  width: 100%;      /* Take up available width of its parent */
}

/* Modal Container */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000; 
}

/* =============================================
   Interactive Elements (General)
   ============================================= */

.search-box {
  flex: 1;
  min-width: 200px;
  padding: 8px 12px;
  border: 2px solid #ddd;
  border-radius: 6px;
  font-size: 14px;
}

.search-box:focus {
  outline: none;
  border-color: #007bff;
  box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25); /* Enhanced glow for search box */
}

/* General Button Styling */
.controls button, .search-nav button {
  padding: 8px 16px;
  margin: 0 4px;
  border: none;
  border-radius: 6px;
  background: #007bff;
  color: white;
  cursor: pointer;
  font-size: 12px;
}

.controls button:hover, .search-nav button:hover {
  background: #0056b3;
}

.controls button.active {
  background: #28a745;
}

/* Search Navigation Buttons (Prev/Next) */
.search-nav button {
  width: 32px;
  height: 32px;
  padding: 0;
}

.search-nav button:disabled {
  background: #ccc;
  cursor: not-allowed;
}

/* Info text in Header */
.search-info {
  font-size: 12px;
  color: #666;
  white-space: nowrap;
}

.hidden-indicator {
  color: #c82333; /* Darker red for better contrast (AA compliant 5.15:1 on #fff) */
  font-size: 11px;
  margin-left: 8px;
}

/* =============================================
   Main Table Styles
   ============================================= */

/* The main data table structure */
.json-table > table {
  width: auto; /* Allow table to be wider than its container if content demands */
  min-width: 100%; /* But at least as wide as its container initially */
  border-collapse: collapse;
  table-layout: auto; 
}

/* Main table header cells */
.json-table > table > thead > tr > th {
  background: #f8f9fa;
  font-weight: 600;
  cursor: pointer;
  user-select: none;
  position: sticky; 
  top: 0; 
  z-index: 100; 
  white-space: nowrap; 
  padding: 10px 12px; 
  text-align: left;
  border-bottom: 1px solid #eee;
  font-size: 13px;
  min-width: 150px;   
  vertical-align: top;
}

.json-table > table > thead > tr > th:hover {
  background: #e9ecef;
}

/* Header cell content layout (for sorting icon, remove button) */
.json-table > table > thead > tr > th > div {
  display: flex;
  align-items: center; 
  justify-content: space-between; 
}

/* Sorting indicators */
.json-table > table > thead > tr > th.sorted::after {
  content: ' ↓';
  color: #007bff;
}

.json-table > table > thead > tr > th.sorted.asc::after {
  content: ' ↑';
}

th.dragging {
  opacity: 0.4;
  background: #f0f0f0 !important; /* Use important if other styles override */
  /* cursor: grabbing; /* Browser usually handles this */
}

th.drag-over {
  outline: 2px dashed #007bff;
  outline-offset: -2px; /* Draw inside the border */
  background-color: #e9ecef !important; /* Light highlight, use important if needed */
}

/* Remove column button in header */
.remove-col-btn-header {
  margin-left: 5px;
  padding: 0px 4px;
  font-size: 10px;
  line-height: 1;
  font-weight: bold;
  cursor: pointer;
  background-color: #dc3545; /* Red for removal */
  color: white;
  border: none;
  border-radius: 3px;
  vertical-align: middle;
}

.remove-col-btn-header:hover {
  background-color: #c82333; /* Darker red */
}

/* Main table data cells */
.json-table > table > tbody > tr > td {
  padding: 10px 12px; 
  text-align: left;
  border-bottom: 1px solid #eee;
  font-size: 13px;
  min-width: 150px;   
  word-wrap: break-word; 
  overflow-wrap: break-word; 
  vertical-align: top;
}

/* Main table row styling */
.json-table > table > tbody > tr:nth-child(even) {
  background: #f8f9fa;
}

.json-table > table > tbody > tr:hover {
  background: #e3f2fd;
}

/* Row Number Column (Sticky) */
.row-number { /* Base style for any row number cell */
  text-align: center;
  width: 50px !important;     
  min-width: 50px !important;  
  max-width: 50px !important;  
  position: sticky;
  left: 0;
  overflow: hidden; 
  text-overflow: ellipsis;
  white-space: normal; /* Allow wrapping if number is too long (unlikely) */
}

.json-table > table > thead > tr > th.row-number {
  font-weight: 600;
  color: #495057;
  background: #f8f9fa; 
  z-index: 150; /* Above other sticky headers */
}

.json-table > table > tbody > tr > td.row-number {
  font-weight: 600;
  color: #495057;
  background: #f8f9fa; 
  z-index: 90; /* Above row content, below sticky header */
}
.json-table > table > tbody > tr:nth-child(even) > td.row-number {
  background: #e9ecef; 
}


/* =============================================
   Expandable / Nested Content Styles
   ============================================= */

.expandable {
  cursor: pointer;
  position: relative;
  background: linear-gradient(135deg, #fff3e0, #fff8e1);
  border-left: 3px solid #ff9800;
  padding: 4px 8px; 
  border-radius: 4px; 
  display: inline-block; 
  max-width: 100%; 
}

.expandable:hover {
  background: linear-gradient(135deg, #ffe0b2, #ffecb3);
}

.toggle {
  display: inline-block;
  width: 20px;
  text-align: center;
  font-weight: bold;
  color: #004085; /* Darker blue for better contrast (e.g., 5.7:1 on #fff3e0) */
  margin-right: 8px;
}

.nested {
  max-height: 0;
  overflow: hidden; 
  transition: max-height 0.3s ease, padding 0.3s ease, margin 0.3s ease;
  background: #f0f8ff; 
  border-left: 2px solid #007bff;
  margin: 0; 
  padding: 0; 
  border-radius: 4px;
}

.nested.expanded {
  max-height: 5000px; 
  padding: 8px 12px;
  margin: 8px 0 4px 20px; 
  overflow-y: auto; 
}

/* Nested Table Styles */
.nested-table {
  font-size: 11px;
  margin: 4px 0; 
  width: max-content; 
  min-width: 100%;   
  table-layout: auto; 
}

.nested-table th,
.nested-table td {
  padding: 6px 8px;
  border-bottom: 1px solid #ddd;
  font-size: 12px; 
  min-width: 100px; 
  word-wrap: break-word;
  overflow-wrap: break-word;
  vertical-align: top;
  white-space: nowrap; 
}

.nested-table th {
  background: #e9ecef; 
  position: sticky; 
  top: 0; 
  z-index: 50; /* Below main table sticky header, above nested content */
  white-space: nowrap;
}

.nested-table td.row-number { 
  text-align: center;
  font-weight: normal; 
  background: #f7f7f7; 
  /* Inherits .row-number base sticky properties if class is applied */
}

/* =============================================
   Special Cell/Content Styling
   ============================================= */

.highlight {
  background: #ffeb3b;
  padding: 1px 2px;
  border-radius: 2px;
  font-weight: bold;
}

.highlight.current {
  background: #ff5722;
  color: white;
  box-shadow: 0 0 4px rgba(255, 87, 34, 0.5);
}

.path-display {
  font-size: 10px;
  color: #666;
  margin-top: 2px;
  font-style: italic;
  word-break: break-all; 
}

/* =============================================
   Specific Button Styles
   ============================================= */

.promote-btn {
  margin-left: 8px; 
  padding: 1px 5px; 
  font-size: 11px;
  line-height: 1.2;
  font-weight: bold;
  cursor: pointer;
  background-color: #28a745; 
  color: white;
  border: none;
  border-radius: 4px;
  vertical-align: middle; 
  box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
  
.promote-btn:hover {
  background-color: #218838; 
  box-shadow: 0 1px 3px rgba(0,0,0,0.15);
}

/* Note: .controls button.active is defined in General Button Styling */

/* =============================================
   Modal Internals
   ============================================= */

.modal-content {
  background: white;
  border-radius: 8px;
  padding: 20px;
  max-width: 90%;
  max-height: 90%;
  overflow: auto;
  position: relative;
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  border-bottom: 1px solid #eee;
  padding-bottom: 15px;
}

.close-btn {
  background: #dc3545;
  color: white;
  border: none;
  border-radius: 4px;
  padding: 8px 12px;
  cursor: pointer;
}

/* =============================================
   Output Areas (SQL, JSON Edit)
   ============================================= */

.sql-output, .json-edit-output { /* Grouped for common properties */
  width: 100%;
  font-family: 'Consolas', monospace; /* Explicitly set, though inherits from body */
  font-size: 12px;
  padding: 15px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: #f8f9fa;
}
  
.sql-output {
  min-height: 300px;
  resize: vertical;
}

/* =============================================
   Feedback & Utility Styles
   ============================================= */

.loading {
  text-align: center;
  padding: 40px;
  color: #666;
}

.no-results {
  text-align: center;
  padding: 40px;
  color: #999;
  font-style: italic;
}

/* Add to your CSS */
.json-edit-output.drag-over-active {
  border: 2px dashed #007bff !important; /* Use !important if needed to override existing styles */
  background-color: #f0f8ff;
}
#json-modal-content.drag-over-active { /* If dropping on modal content */
    outline: 2px dashed #007bff;
    outline-offset: -10px; /* Adjust as needed */
}

/* =============================================
   Focus Styles (Accessibility)
   ============================================= */

/* General Focus Styles for Interactive Elements */
.controls button:focus, 
.search-nav button:focus,
.remove-col-btn-header:focus,
.promote-btn:focus,
.close-btn:focus,
.expandable[role="button"]:focus, /* For clickable expand/collapse areas */
th[role="button"]:focus, /* For sortable table headers */
.modal-footer button:focus, /* Buttons in modal footer */
.modal-header select:focus, /* Select in modal header */
.promote-popover-btn:focus, /* Buttons in promote popover */
button:focus, /* A general fallback for other buttons if needed */
select:focus /* For the dialect select */
 {
  outline: 2px solid #0056b3; /* A distinct blue, adjust color as needed */
  outline-offset: 1px;         /* Small offset so outline doesn't overlap element too much */
  box-shadow: 0 0 0 2px rgba(0, 86, 179, 0.3); /* Optional: softer glow */
}

/* Input file button styling when hidden input is focused (for keyboard users) */
input[type="file"]:focus + button {
  outline: 2px solid #0056b3;
  outline-offset: 1px;
  box-shadow: 0 0 0 2px rgba(0, 86, 179, 0.3);
}


/* Ensure textarea focus is also clear */
.sql-output:focus,
.json-edit-output:focus {
  border-color: #007bff;
  box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
  outline: none; /* If using box-shadow for focus, outline might be redundant */
}

/* For popover buttons - specific style if needed to override general button:focus */
.promote-popover-btn:focus {
  /* General style above should cover, but can add specific overrides here */
  background-color: #e9ecef; /* Add a background change for better visibility */
}
/* In Special Cell/Content Styling or a new section */
.value-special.value-null,
.value-special.value-undefined {
  color: #999; /* Light grey */
}
/* Ensure highlighting within special text is still visible */
.value-special .highlight {
  color: initial; /* Or specific color if grey clashes */
  /* background remains from .highlight */
}
</style>
  
</head>
<body>
  <div id="app">
    <div class="loading" role="status" aria-live="polite">Loading JSON data...</div>
  </div>

  <script type="module">

// --- START OF INLINED sqlGenerator.js ---
const sqlEscapeString = (str) => {
    if (str === null || str === undefined) return 'NULL';
    return str.replace(/'/g, "''");
};

const buildBaseAccessPath = (fullItemPath, rootDbColumnName, dbDialect, tableAlias = null, forFlattenInput = false) => {
    let pathPrefix = tableAlias ? `"${tableAlias}".` : '';
    let pathWithinRoot = fullItemPath.substring(rootDbColumnName.length);
    if (pathWithinRoot.startsWith('.')) {
        pathWithinRoot = pathWithinRoot.substring(1);
    }

    if (dbDialect === 'postgresql') {
        let pgPath = `${pathPrefix}"${rootDbColumnName}"`;
        // If no pathWithinRoot, it means we are accessing the rootDbColumnName itself.
        // If forFlattenInput, return as is (expecting JSONB input for functions like jsonb_array_elements,
        // actual cast to jsonb will be handled at call site if root is json).
        // If for SELECT, cast to text.
        if (!pathWithinRoot) return forFlattenInput ? pgPath : `${pgPath}::text`;

        const segments = pathWithinRoot.replace(/\[(\d+)\]/g, '.$1').split('.');
        segments.forEach((seg, idx) => {
            const isLastSegment = idx === segments.length - 1;
            // For intermediate paths or for FLATTEN input, use '->'
            // For the final segment in a SELECT, use '->>' to get text
            pgPath += (forFlattenInput || !isLastSegment) ? '->' : '->>';
            if (seg.match(/^\d+$/)) pgPath += seg; // Array index
            else pgPath += `'${sqlEscapeString(seg)}'`; // Object key
        });
        return pgPath;
    } else if (dbDialect === 'snowflake') {
        // Base access string, defaults to direct column access
        let sfAccessBase = `${pathPrefix}"${rootDbColumnName}"`;

        const needsParsing = pathWithinRoot || forFlattenInput;

        if (needsParsing) {
            sfAccessBase = `parse_json(${pathPrefix}"${rootDbColumnName}"::variant)`;
        }

        if (!pathWithinRoot) {
            return sfAccessBase;
        }

        let sfPath = sfAccessBase;
        const pathParts = pathWithinRoot.replace(/\[(\d+)\]/g, '[$1]').split('.');
        pathParts.forEach(part => {
            if (part.startsWith('[') && part.endsWith(']')) { // Array index
                sfPath += part;
            } else { // Object key
                sfPath += `:${part.replace(/:/g, "\\:")}`;
            }
        });
        return forFlattenInput ? sfPath : `${sfPath}::VARCHAR`;
    }
    // Fallback for unsupported dialect
    return `"${fullItemPath}"`;
};

const buildPathWithinElement = (elementBase, valuePathWithin, dbDialect) => {
    // elementBase is like 'f0.value' (Snowflake) or 'flat_alias.element_value' (PostgreSQL)
    // This element is already a JSON object/variant, so no initial parse_json needed here.

    if (dbDialect === 'postgresql') {
        let pgPath = elementBase; // This will be jsonb if coming from jsonb_array_elements
        if (!valuePathWithin) return `${pgPath}::text`; // Cast jsonb to text

        const segments = valuePathWithin.replace(/\[(\d+)\]/g, '.$1').split('.');
        segments.forEach((seg, idx) => {
            pgPath += (idx === segments.length - 1 ? '->>' : '->'); // -> on jsonb returns jsonb, ->> returns text
            if (seg.match(/^\d+$/)) pgPath += seg;
            else pgPath += `'${sqlEscapeString(seg)}'`;
        });
        return pgPath;
    } else if (dbDialect === 'snowflake') {
        let sfPath = elementBase; // e.g., f0.value which is a VARIANT
        if (!valuePathWithin) return `${sfPath}::VARCHAR`;

        const pathParts = valuePathWithin.replace(/\[(\d+)\]/g, '[$1]').split('.');
        pathParts.forEach(part => {
            if (part.startsWith('[') && part.endsWith(']')) {
                sfPath += part;
            } else {
                sfPath += `:${part.replace(/:/g, "\\:")}`;
            }
        });
        return `${sfPath}::VARCHAR`;
    }
    // Fallback
    return `${elementBase}${valuePathWithin ? '.' + valuePathWithin : ''}`;
};

const generateSQL = (visibleColumns, dialect = 'snowflake') => {
    try {
        const tableName = 'json_data'; // Note: Your example query uses 'cloudtrail_logs'. This might need to be configurable.
        const columns = visibleColumns;

        if (!columns || columns.length === 0) {
            return '-- No columns selected';
        }

        const mainTableAlias = "e";
        let fromParts = [`"${tableName}" AS "${mainTableAlias}"`]; // Adjust if your table name is different
        let selectExpressions = [];
        let whereConditions = [];
        let flattenCounter = 0;

        columns.forEach(col => {
            const uiColumnAlias = col.replace(/[.\[\]=:"']/g, '_');
            const rootDbColumnName = col.split(/[.\[]/)[0];
            const complexPathRegex = /^(.+?)\[([^=\]]+)="([^"]+)"\](?:\.(.+))?$/;
            const complexMatch = col.match(complexPathRegex);

            if (complexMatch) { // Path like "array_col[key="val"].field"
                const flattenAlias = `f${flattenCounter++}`;
                const fullPathToArray = complexMatch[1];
                const keyFieldInArrayElement = complexMatch[2];
                const keyValueInArrayElement = complexMatch[3].replace(/\\"/g, '"');
                const valueFieldPathWithinElement = complexMatch[4];

                const rootForArrayPath = fullPathToArray.split(/[.\[]/)[0];

                if (dialect === 'postgresql') {
                    const pgPathToArrForFlatten = buildBaseAccessPath(fullPathToArray, rootForArrayPath, 'postgresql', mainTableAlias, true);
                    // MODIFICATION: Added ::jsonb cast to the input of jsonb_array_elements
                    fromParts.push(`, LATERAL jsonb_array_elements((${pgPathToArrForFlatten})::jsonb) AS ${flattenAlias}(element_value)`);
                    
                    const selectPath = buildPathWithinElement(`${flattenAlias}.element_value`, valueFieldPathWithinElement, 'postgresql');
                    selectExpressions.push(`${selectPath} AS "${uiColumnAlias}"`);
                    
                    // element_value is jsonb, ->> extracts text for comparison
                    whereConditions.push(`${flattenAlias}.element_value->>'${sqlEscapeString(keyFieldInArrayElement)}' = '${sqlEscapeString(keyValueInArrayElement)}'`);
                } else if (dialect === 'snowflake') {
                    const sfPathToArrForFlatten = buildBaseAccessPath(fullPathToArray, rootForArrayPath, 'snowflake', mainTableAlias, true);
                    fromParts.push(`, LATERAL FLATTEN(input => ${sfPathToArrForFlatten}) AS ${flattenAlias}`);

                    const selectPath = buildPathWithinElement(`${flattenAlias}.value`, valueFieldPathWithinElement, 'snowflake');
                    selectExpressions.push(`${selectPath} AS "${uiColumnAlias}"`);
                    
                    let keyAccessPath = `${flattenAlias}.value`; 
                    const keyFieldParts = keyFieldInArrayElement.replace(/\[(\d+)\]/g, '[$1]').split('.');
                     keyFieldParts.forEach(part => {
                        if (part.startsWith('[') && part.endsWith(']')) keyAccessPath += part;
                        else keyAccessPath += `:${part.replace(/:/g, "\\:")}`;
                    });
                    whereConditions.push(`${keyAccessPath}::VARCHAR = '${sqlEscapeString(keyValueInArrayElement)}'`);
                }
            } else { // Simple path like "id" or "user.name"
                selectExpressions.push(`${buildBaseAccessPath(col, rootDbColumnName, dialect, mainTableAlias, false)} AS "${uiColumnAlias}"`);
            }
        });
        
        let sql = `SELECT\n  ${selectExpressions.join(',\n  ')}\nFROM ${fromParts.join('\n  ')}`;
        if (whereConditions.length > 0) {
            sql += `\nWHERE ${whereConditions.join('\n  AND ')};`;
        } else {
            sql += ';';
        }

        return sql;

    } catch (e) {
        console.error("Error generating SQL:", e);
        return `-- Error generating SQL: ${e.message}\n-- Stack: ${e.stack ? e.stack.split('\n').map(s => `-- ${s}`).join('\n') : ''}`;
    }
};
// --- END OF INLINED sqlGenerator.js ---

// --- START OF INLINED state.js ---
// state.js

// Reactive state management
const createReactiveState = (initial) => {
    const listeners = new Set();
    const state = new Proxy(initial, {
      set(target, key, value) {
        const oldValue = target[key];
        if (oldValue !== value) {
          if ((key === 'expandedPaths' || key === 'allPossibleColumns') && value instanceof Set && oldValue instanceof Set) { // Updated for allPossibleColumns
             if (value.size !== oldValue.size || ![...value].every(item => oldValue.has(item))) {
                target[key] = value;
                listeners.forEach(fn => fn(key, value));
             }
          } else if (key === 'visibleColumns' && Array.isArray(value) && Array.isArray(oldValue)) {
              if (value.length !== oldValue.length || value.some((item, i) => item !== oldValue[i])) {
                  target[key] = value;
                  listeners.forEach(fn => fn(key, value));
              }
          }
          else {
            target[key] = value;
            listeners.forEach(fn => fn(key, value));
          }
        }
        return true;
      }
    });
    
    state.subscribe = (fn) => {
      listeners.add(fn);
      return () => listeners.delete(fn);
    };
    
    state.notify = (changedKey = null) => { 
      listeners.forEach(fn => fn(changedKey));
    };
    
    return state;
  };
  
  // Application state
 const state = createReactiveState({
    data: [],
    searchQuery: '',
    expandedPaths: new Set(),
    visibleColumns: [],
    sortBy: null,
    sortDirection: 'asc',
    showPaths: false,
    searchResults: [],
    currentSearchIndex: -1,
    showSqlModal: false,
    sqlDialect: 'snowflake', // Default to Snowflake
    editModeActive: false,
    showJsonModal: false,       // Controls visibility of the JSON edit modal
    rawJsonEditContent: '',   // Holds the string content of the JSON editor
    jsonValidationMessage: '', // Message for JSON validation status
    showPromoteKeyPopover: false, 
    promoteKeyPopoverContext: null, 
    allPossibleColumns: new Set(),    // NEW: Stores all discovered column paths
    showAddColumnPopover: false,      // NEW: Controls visibility of "Add Column" popover
    addColumnPopoverAnchor: null,     // NEW: Anchor element for "Add Column" popover
    showCsvModal: false,          // Controls visibility of the CSV export modal
    csvOutputContent: '',       // Holds the generated CSV string
  });

// --- END OF INLINED state.js ---

// --- START OF INLINED utils.js ---
// utils.js

const escapeStringForDataAttribute = (str) => {
  if (typeof str !== 'string') return str;
  return str.replace(/&/g, '&') // Escape ampersands first
            .replace(/"/g, '"'); // Escape double quotes
};

const flatten = (obj, prefix = '', result = []) => {
  if (!obj || typeof obj !== 'object') {
    if (prefix) result.push({ path: prefix, value: obj });
    return result;
  }
  
  if (Array.isArray(obj)) {
    obj.forEach((item, index) => {
      const arrayPath = prefix ? `${prefix}[${index}]` : `[${index}]`;
      if (item && typeof item === 'object') {
        flatten(item, arrayPath, result);
      } else {
        result.push({ path: arrayPath, value: item });
      }
    });
  } else {
    Object.entries(obj).forEach(([key, value]) => {
      const path = prefix ? `${prefix}.${key}` : key;
      if (value && typeof value === 'object') {
        flatten(value, path, result);
      } else {
        result.push({ path, value });
      }
    });
  }
  
  return result;
};

const getAllObjectPaths = (obj, currentPath = '', allPaths = []) => {
  if (obj && typeof obj === 'object') {
      if (currentPath) {
          allPaths.push(currentPath);
      }

      if (Array.isArray(obj)) {
          obj.forEach((item, index) => {
              const newPath = currentPath ? `${currentPath}[${index}]` : `[${index}]`;
              getAllObjectPaths(item, newPath, allPaths);
          });
      } else {
          for (const key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) {
                  const newPath = currentPath ? `${currentPath}.${key}` : key;
                  getAllObjectPaths(obj[key], newPath, allPaths);
              }
          }
      }
  }
  return allPaths;
};

const getValue = (obj, path) => {
  if (!obj || !path) return undefined;
  
  try {
      if (!path.includes('.') && !path.includes('[')) {
          return obj[path];
      }

      let processedPath = path.replace(/\[(\d+)\]/g, '.$1'); 
      const pathSegments = processedPath.split('.');
      
      let current = obj;
      const arraySelectorRegex = /^(\w+)\[(.+?)="([^"]*)"\]$/; 

      for (const segment of pathSegments) {
          if (current == null) return undefined;

          const selectorMatch = segment.match(arraySelectorRegex);
          
          if (selectorMatch) {
              const arrayNameInSegment = selectorMatch[1];
              const keyField = selectorMatch[2]; 
              const keyValue = selectorMatch[3].replace(/\\"/g, '"'); 
              
              const arrayItself = current[arrayNameInSegment];
              if (!Array.isArray(arrayItself)) return undefined; 
              
              const foundItem = arrayItself.find(item => item && typeof item === 'object' && String(item[keyField]) === keyValue);
              if (!foundItem) return undefined; 
              current = foundItem; 
          } else {
              current = current[segment];
          }
      }
      return current;
  } catch (e) {
      return undefined;
  }
};

const highlightText = (text, query, isActive = false) => {
  if (text === null || text === undefined) text = '';
  if (!query) return String(text);
  const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const regex = new RegExp(`(${escapedQuery})`, 'gi');
  return String(text).replace(regex, `<span class="highlight ${isActive ? 'current' : ''}">$1</span>`);
};

const performSearch = (data, query) => {
  if (!query) return [];
  const results = [];
  data.forEach((row, rowIndex) => {
    const flattened = flatten(row); 
    flattened.forEach(({ path, value }) => {
      const strValue = String(value).toLowerCase();
      if (strValue.includes(query.toLowerCase())) {
        results.push({ rowIndex, path, value: String(value) });
      }
    });
  });
  return results;
};

const escapeCsvField = (field) => {
  if (field === null || field === undefined) {
      return '';
  }
  const stringField = String(field);
  if (stringField.includes(',') || stringField.includes('\n') || stringField.includes('"')) {
      return `"${stringField.replace(/"/g, '""')}"`;
  }
  return stringField;
};

const processCellValueForRecord = (valueString) => {
  const trimmedValue = typeof valueString === 'string' ? valueString.trim() : valueString;
  if (typeof trimmedValue === 'string' &&
      ((trimmedValue.startsWith('{') && trimmedValue.endsWith('}')) ||
       (trimmedValue.startsWith('[') && trimmedValue.endsWith(']')))) {
      try {
          return JSON.parse(trimmedValue);
      } catch (e1) {
          try {
              const repairedJSONString = trimmedValue.replace(/""/g, '"');
              return JSON.parse(repairedJSONString);
          } catch (e2) {
              return valueString; 
          }
      }
  }
  return valueString;
};

const robustParseCSV = (csvString, delimiter = '\t') => {
  const objects = [];
  let headers = [];
  
  let currentRow = [];
  let currentField = "";
  let inQuotedField = false;
  let i = 0;

  csvString = csvString.replace(/\r\n?/g, '\n').trim();

  if (csvString === "") {
      robustParseCSV.lastHeaders = [];
      return [];
  }

  while (i < csvString.length) {
      const char = csvString[i];

      if (inQuotedField) {
          if (char === '"') {
              if (i + 1 < csvString.length && csvString[i + 1] === '"') {
                  currentField += '"';
                  i++; 
              } else {
                  inQuotedField = false;
              }
          } else {
              currentField += char; 
          }
      } else { 
          if (char === '"') {
              if (currentField === "") { 
                  inQuotedField = true;
              } else {
                  currentField += char; 
              }
          } else if (char === delimiter) {
              currentRow.push(currentField);
              currentField = "";
          } else if (char === '\n') {
              currentRow.push(currentField);
              currentField = "";

              if (headers.length === 0) {
                  headers = currentRow.map(h => h.trim());
              } else {
                  if (currentRow.some(val => val !== undefined && (typeof val === 'string' ? val.trim() !== '' : true))) {
                      const record = {};
                      headers.forEach((header, index) => {
                          const H = header || `_col_${index+1}`;
                          const rawValue = currentRow[index] !== undefined ? currentRow[index] : "";
                          record[H] = processCellValueForRecord(rawValue);
                      });
                      objects.push(record);
                  }
              }
              currentRow = [];
          } else {
              currentField += char;
          }
      }
      i++;
  }

  currentRow.push(currentField); 

  if (currentRow.length > 0) {
      if (headers.length === 0) { 
          headers = currentRow.map(h => h.trim());
      } else {
          if (currentRow.some(val => val !== undefined && (typeof val === 'string' ? val.trim() !== '' : true))) {
              const record = {};
              headers.forEach((header, index) => {
                  const H = header || `_col_${index+1}`;
                  const rawValue = currentRow[index] !== undefined ? currentRow[index] : "";
                  record[H] = processCellValueForRecord(rawValue);
              });
              objects.push(record);
          }
      }
  }
  
  if (headers.length > 0 && headers.every(h => h === '')) {
      console.warn("CSV Warning: All parsed headers are empty. CSV might be malformed or start with an empty line treated as headers.");
      headers = []; 
  }

  robustParseCSV.lastHeaders = headers.filter(h => h !== ''); 
  return objects;
};
robustParseCSV.lastHeaders = []; 

const detectDelimiter = (textSample) => {
  if (!textSample || textSample.trim() === '') return ','; 
  const firstLineBreak = textSample.indexOf('\n');
  const firstLine = firstLineBreak === -1 ? textSample.trim() : textSample.substring(0, firstLineBreak).trim();

  if (firstLine.length === 0) return ','; 

  const delimiters = [
      { char: ',', count: (firstLine.match(/,/g) || []).length },
      { char: '\t', count: (firstLine.match(/\t/g) || []).length },
      { char: '|', count: (firstLine.match(/\|/g) || []).length },
  ];

  const presentDelimiters = delimiters.filter(d => d.count > 0);

  if (presentDelimiters.length === 0) {
      return ',';
  }

  presentDelimiters.sort((a, b) => b.count - a.count);
  return presentDelimiters[0].char;
};


// --- END OF INLINED utils.js ---

// --- START OF INLINED ui.js ---
// Focus Management
let previouslyFocusedElement = null;

function openModalFocus(modalElementQuerySelector) {
    previouslyFocusedElement = document.activeElement;
    requestAnimationFrame(() => {
        const modal = document.querySelector(modalElementQuerySelector);
        if (modal) {
            const firstFocusableElement = modal.querySelector(
                'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            if (firstFocusableElement) {
                firstFocusableElement.focus();
            }
            modal.addEventListener('keydown', trapFocusInModal);
        }
    });
}

function closeModalFocus(modalElementQuerySelector) {
    const modal = document.querySelector(modalElementQuerySelector);
    if (modal) {
        modal.removeEventListener('keydown', trapFocusInModal);
    }
    if (previouslyFocusedElement) {
        if (document.body.contains(previouslyFocusedElement) && typeof previouslyFocusedElement.focus === 'function') {
           previouslyFocusedElement.focus();
        }
        previouslyFocusedElement = null;
    }
}

function trapFocusInModal(e) {
    if (e.key !== 'Tab') return;
    const modal = e.currentTarget;
    const focusableElements = Array.from(
        modal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])')
    ).filter(el => el.offsetParent !== null && !el.disabled);
    if (focusableElements.length === 0) return;
    const firstFocusableElement = focusableElements[0];
    const lastFocusableElement = focusableElements[focusableElements.length - 1];
    if (e.shiftKey) {
        if (document.activeElement === firstFocusableElement) {
            lastFocusableElement.focus();
            e.preventDefault();
        }
    } else {
        if (document.activeElement === lastFocusableElement) {
            firstFocusableElement.focus();
            e.preventDefault();
        }
    }
}

const scrollToCurrentSearchResult = () => {
  const currentResultElement = document.querySelector('.highlight.current');
  if (currentResultElement) {
    currentResultElement.scrollIntoView({
      behavior: 'smooth',
      block: 'center', 
      inline: 'nearest' 
    });
  }
};

const expandToResult = (result) => {
  try {
    const pathParts = result.path.replace(/\[(\d+)\]/g, '.$1').split('.');
    let currentPath = '';
    let needsExpandedPathNotify = false;
    
    pathParts.forEach((part, index) => {
      currentPath = index === 0 ? part : `${currentPath}.${part}`;
      const objectPathForExpansion = currentPath.replace(/\.(\d+)(?=\.|$)/g, '[$1]');
      const value = getValue(state.data[result.rowIndex], objectPathForExpansion);
      if (index < pathParts.length - 1 && value && typeof value === 'object') {
        if (!state.expandedPaths.has(`${result.rowIndex}-${objectPathForExpansion}`)) {
            state.expandedPaths.add(`${result.rowIndex}-${objectPathForExpansion}`);
            needsExpandedPathNotify = true;
        }
      }
    });
    
    const finalValue = getValue(state.data[result.rowIndex], result.path);
     if (finalValue && typeof finalValue === 'object' && !state.expandedPaths.has(`${result.rowIndex}-${result.path}`)) {
         state.expandedPaths.add(`${result.rowIndex}-${result.path}`);
         needsExpandedPathNotify = true;
     }

    const rootColumn = result.path.split(/[.\[]/)[0];
    let columnChanged = false;
    const newVisibleColumns = [...state.visibleColumns];

    if (!newVisibleColumns.includes(result.path) && !newVisibleColumns.includes(rootColumn)) {
        newVisibleColumns.push(rootColumn);
        columnChanged = true;
    }
    
    if (columnChanged) {
        state.visibleColumns = newVisibleColumns; 
        updateAllPossibleColumns();
    }

    if (needsExpandedPathNotify) {
        state.notify('expandedPaths'); 
    }
    
    requestAnimationFrame(scrollToCurrentSearchResult);

  } catch (e) {
    console.warn('Error expanding to result:', e);
  }
};

const updateAllPossibleColumns = () => {
  const newAllPossible = new Set();
  state.data.forEach(row => {
      if (row && typeof row === 'object' && row !== null) {
          Object.keys(row).forEach(key => newAllPossible.add(key));
      }
  });
  state.visibleColumns.forEach(colPath => newAllPossible.add(colPath));
  state.allPossibleColumns.forEach(colPath => newAllPossible.add(colPath));
  if (newAllPossible.size !== state.allPossibleColumns.size || ![...newAllPossible].every(item => state.allPossibleColumns.has(item))) {
      state.allPossibleColumns = newAllPossible;
  }
};

const generateCSV = () => {
  if (!state.data || state.data.length === 0) {
      return 'No data to export.';
  }
  if (!state.visibleColumns || state.visibleColumns.length === 0) {
      return 'No columns currently visible for export.';
  }
  const headers = state.visibleColumns.map(header => escapeCsvField(header));
  const rows = state.data.map(row => {
      return state.visibleColumns.map(colKey => {
          const value = getValue(row, colKey);
          let cellValue;
          if (value === null || value === undefined) {
              cellValue = '';
          } else if (typeof value === 'object') {
              const stringified = JSON.stringify(value);
              const previewLength = 15;
              const preview = stringified.substring(0, previewLength);
              const prefix = Array.isArray(value) ? "<Json Array> " : "<Json Object> ";
              cellValue = prefix + preview + (stringified.length > previewLength ? "..." : "");
          } else {
              cellValue = String(value);
          }
          return escapeCsvField(cellValue);
      }).join(',');
  });
  return [headers.join(','), ...rows].join('\n');
};

const renderCsvModal = () => {
  if (!state.showCsvModal) return '';
  return `
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="csv-modal-title">
      <div id="csv-modal-content-wrapper" class="modal-content" style="width: 900px; display: flex; flex-direction: column; max-height: 80vh;">
        <div class="modal-header">
          <h3 id="csv-modal-title">CSV Export</h3>
          <div>
            <button data-action="copy-csv" style="margin-right: 10px;">Copy CSV</button>
            <button data-action="download-csv" style="margin-right: 10px;">Download CSV</button>
            <button class="close-btn" data-action="close-csv" aria-label="Close CSV modal">×</button>
          </div>
        </div>
        <textarea id="csv-output-area" class="sql-output" readonly style="flex-grow: 1; width: 100%; resize: none; margin-top: 10px;">${escapeStringForDataAttribute(state.csvOutputContent)}</textarea>
        <div style="font-size: 12px; color: #666; margin-top: 5px;">Exports currently visible top-level columns. Nested objects/arrays are summarized.</div>
      </div>
    </div>
  `;
};
  
const renderHeader = () => {
  const hiddenCount = state.searchResults.filter(result => {
      const rootColumn = result.path.split(/[.\[]/)[0];
      return !state.visibleColumns.includes(rootColumn) && !state.visibleColumns.includes(result.path);
    }
  ).length;

  return `
    <div class="header">
      <input 
        aria-label="Search JSON content"
        id="json-browser-search-box" 
        type="text" 
        class="search-box" 
        placeholder="Search (Press Enter)" 
        value="${escapeStringForDataAttribute(state.searchQuery)}"
        data-action="search"
      >
      <div class="search-nav">
        <button aria-label="Previous search result" data-action="search-prev" ${state.searchResults.length === 0 ? 'disabled' : ''}>←</button>
        <button aria-label="Next search result" data-action="search-next" ${state.searchResults.length === 0 ? 'disabled' : ''}>→</button>
      </div>
      <div class="controls">
        <button data-action="reset-view">Reset View</button>
        <button data-action="expand-all">Expand All</button>
        <button data-action="collapse-all">Collapse All</button>
        <button data-action="toggle-paths" class="${state.showPaths ? 'active' : ''}">
          Paths
        </button>
        <button data-action="toggle-edit-mode" class="${state.editModeActive ? 'active' : ''}">
          ${state.editModeActive ? 'Done Editing' : 'Edit Mode'}
        </button>
        ${state.editModeActive ? `<button id="add-column-button" data-action="show-add-column-popover" aria-haspopup="true" aria-expanded="${state.showAddColumnPopover}">Add Column +</button>` : ''}
        <button data-action="show-sql">SQL</button>
        <button data-action="show-json">View/Edit Data</button>
        <button data-action="show-csv">Export CSV</button>
      </div>
      <div class="search-info" role="status" aria-live="polite" aria-atomic="true">
        ${state.searchResults.length > 0 
          ? `${state.currentSearchIndex + 1} of ${state.searchResults.length}${hiddenCount > 0 ? `<span class="hidden-indicator">(${hiddenCount} hidden)</span>` : ''}` 
          : state.searchQuery && state.searchResults.length === 0 ? 'No matches' : `${state.data.length} rows`}
      </div>
    </div>
  `;
};

const renderCell = (value, path, rowIndex, isNestedCall = false) => {
  const isExpandable = value && typeof value === 'object';
  const expandKey = `${rowIndex}-${path}`;
  const isExpanded = state.expandedPaths.has(expandKey);
  const isTopLevelCell = !isNestedCall;

  let cellDisplayHtml = '';
  const currentResult = state.searchResults[state.currentSearchIndex];
  const isCurrentMatchForHighlight = currentResult &&
                                    currentResult.rowIndex === rowIndex &&
                                    currentResult.path === path;

  if (isExpandable) {
      const displayValueText = Array.isArray(value) 
          ? `Array(${value.length})` 
          : `Object(${Object.keys(value).length})`;
      const highlightedDisplayValue = highlightText(displayValueText, state.searchQuery, isCurrentMatchForHighlight && !isExpanded);
      
      const nestedContentId = `nested-content-${rowIndex}-${path.replace(/[^a-zA-Z0-9_-]/g, '_')}`;
      const nestedDivContent = isExpanded ? renderNestedObject(value, path, rowIndex) : '';
      
      cellDisplayHtml = `
        <div 
          class="expandable" 
          data-action="toggle" 
          data-path="${escapeStringForDataAttribute(path)}" 
          data-row="${rowIndex}"
          role="button"
          tabindex="0"
          aria-expanded="${isExpanded ? 'true' : 'false'}"
          aria-controls="${nestedContentId}">
          <span class="toggle" aria-hidden="true">${isExpanded ? '−' : '+'}</span>
          ${highlightedDisplayValue}
        </div>
        <div class="nested ${isExpanded ? 'expanded' : ''}" id="${nestedContentId}" data-parent-path="${escapeStringForDataAttribute(path)}" data-row-index-for-nested="${rowIndex}">
          ${nestedDivContent}
        </div>
      `;
  } else {
      let textForHighlighting;
      let finalDisplay;
      if (isTopLevelCell) {
          if (value === null) {
              textForHighlighting = '<null>';
              finalDisplay = `<span class="value-special value-null">${highlightText(textForHighlighting, state.searchQuery, isCurrentMatchForHighlight)}</span>`;
          } else if (value === undefined) {
              textForHighlighting = '<undefined>';
              finalDisplay = `<span class="value-special value-undefined">${highlightText(textForHighlighting, state.searchQuery, isCurrentMatchForHighlight)}</span>`;
          } else {
              textForHighlighting = String(value);
              finalDisplay = highlightText(textForHighlighting, state.searchQuery, isCurrentMatchForHighlight);
          }
      } else {
          textForHighlighting = (value === null || value === undefined) ? '' : String(value);
          finalDisplay = highlightText(textForHighlighting, state.searchQuery, isCurrentMatchForHighlight);
      }
      cellDisplayHtml = finalDisplay;
      const isPrimitive = value !== null && value !== undefined && typeof value !== 'object';
      if (state.editModeActive && isPrimitive && isNestedCall) { 
          cellDisplayHtml += `
            <button 
              class="promote-btn" 
              data-action="promote-value" 
              data-path-to-value="${escapeStringForDataAttribute(path)}" 
              data-row-index="${rowIndex}"
              aria-label="Promote '${escapeStringForDataAttribute(path)}' to column"
              title="Promote '${escapeStringForDataAttribute(path)}' to column"
            >+</button>`;
      }
  }
  
  const pathDisplay = state.showPaths ? `<div class="path-display">${path}</div>` : '';
  
  if (isTopLevelCell) {
      return `<td class="${path === 'id' ? 'col-id' : ''}"><div>${cellDisplayHtml}</div>${pathDisplay}</td>`;
  } else {
      return `<div>${cellDisplayHtml}</div>`;
  }
};

const renderNestedObject = (obj, basePath, rowIndex) => {
  if (!obj || typeof obj !== 'object') {
    const currentResult = state.searchResults[state.currentSearchIndex];
    const isCurrentMatch = currentResult && 
      currentResult.rowIndex === rowIndex && 
      currentResult.path === basePath;
    
    let promoteButtonHtml = '';
    const isPrimitive = obj !== null && obj !== undefined && typeof obj !== 'object';
    if (state.editModeActive && isPrimitive) { 
      promoteButtonHtml = `
        <button 
          class="promote-btn" 
          data-action="promote-value" 
          data-path-to-value="${escapeStringForDataAttribute(basePath)}" 
          data-row-index="${rowIndex}"
          aria-label="Promote '${escapeStringForDataAttribute(basePath)}' to column"
          title="Promote '${escapeStringForDataAttribute(basePath)}' to column"
        >+</button>`;
    }
    return `<div>${highlightText(String(obj || ''), state.searchQuery, isCurrentMatch)}${promoteButtonHtml}</div>`;
  }
  
  let rows = '';
  let tableHtml = '';

  if (Array.isArray(obj)) {
    if (obj.length === 0) {
      return '<div><i>(empty array)</i></div>';
    }
    const firstItem = obj[0];
    let isArrayOfObjects = typeof firstItem === 'object' && firstItem !== null && !Array.isArray(firstItem);
    if (isArrayOfObjects) {
      const columnKeys = new Set();
      const sampleSize = Math.min(obj.length, 10); 
      for (let i = 0; i < sampleSize; i++) {
          if (typeof obj[i] === 'object' && obj[i] !== null && !Array.isArray(obj[i])) {
              Object.keys(obj[i]).forEach(key => columnKeys.add(key));
          }
      }
      if (columnKeys.size === 0) {
           if (obj.every(item => typeof item === 'object' && item !== null && !Array.isArray(item) && Object.keys(item).length === 0)) {
              isArrayOfObjects = false; 
           } else {
              isArrayOfObjects = false;
           }
      }
      if (isArrayOfObjects) { 
          const headers = Array.from(columnKeys).sort(); 
          let headerRow = '<tr>'; 
          headers.forEach(header => {
              const currentResult = state.searchResults[state.currentSearchIndex];
              const isHeaderMatch = currentResult && state.searchQuery &&
                                  header.toLowerCase().includes(state.searchQuery.toLowerCase()) &&
                                  currentResult.path.startsWith(basePath);
              headerRow += `<th>${highlightText(header, state.searchQuery, isHeaderMatch)}</th>`;
          });
          headerRow += '</tr>';
          let bodyRows = obj.map((item, index) => {
              const itemBasePath = `${basePath}[${index}]`;
              let rowCells = ``; 
              if (typeof item === 'object' && item !== null && !Array.isArray(item)) {
                  headers.forEach(key => {
                      const cellPath = `${itemBasePath}.${key}`;
                      const cellContent = renderCell(item[key], cellPath, rowIndex, true); 
                      const pathDisplay = state.showPaths ? `<div class="path-display">${cellPath}</div>` : '';
                      rowCells += `<td>${cellContent}${pathDisplay}</td>`;
                  });
              } else { 
                  const cellContent = renderCell(item, itemBasePath, rowIndex, true);
                  const pathDisplay = state.showPaths ? `<div class="path-display">${itemBasePath}</div>` : '';
                  rowCells += `<td colspan="${headers.length}">${cellContent}${pathDisplay}</td>`;
              }
              return `<tr>${rowCells}</tr>`;
          }).join('');
          tableHtml = `<table class="nested-table"><thead>${headerRow}</thead><tbody>${bodyRows}</tbody></table>`;
      }
    } 
    if (!isArrayOfObjects) { 
      rows = obj.map((item, index) => {
        const itemPath = `${basePath}[${index}]`;
        const itemContent = renderCell(item, itemPath, rowIndex, true); 
        const pathDisplay = state.showPaths ? `<div class="path-display">${itemPath}</div>` : '';
        return `
          <tr>
            <td class="row-number">[${index}]</td>
            <td>${itemContent}${pathDisplay}</td> 
          </tr>
        `;
      }).join('');
      tableHtml = `<table class="nested-table"><tbody>${rows}</tbody></table>`;
    }
  } else {  
      rows = Object.entries(obj).map(([key, value]) => {
        const itemPath = `${basePath}.${key}`;
        const valueContent = renderCell(value, itemPath, rowIndex, true); 
        const pathDisplay = state.showPaths ? `<div class="path-display">${itemPath}</div>` : '';
        const currentResult = state.searchResults[state.currentSearchIndex];
        const isKeyMatch = currentResult && state.searchQuery &&
          key.toLowerCase().includes(state.searchQuery.toLowerCase()) && 
          currentResult.path.startsWith(basePath);
      return `
          <tr>
            <td><div><strong>${highlightText(key, state.searchQuery, isKeyMatch)}</strong></div></td>
            <td>${valueContent}${pathDisplay}</td>
          </tr>
      `;
      }).join('');
      tableHtml = `<table class="nested-table"><tbody>${rows}</tbody></table>`;
  }
  return tableHtml;
};

const renderTable = () => {
  if (state.data.length === 0 && !state.showJsonModal) {
    return '<div class="no-results" role="status" aria-live="polite">No data available. Click "View/Edit Data" to load or paste data.</div>';
  }
  if (state.data.length === 0 && state.showJsonModal) {
      return '';
  }

  const sortedData = [...state.data];
  if (state.sortBy) {
    sortedData.sort((a, b) => {
      const aVal = getValue(a, state.sortBy);
      const bVal = getValue(b, state.sortBy);
      let comparison = 0;
      if (typeof aVal === 'number' && typeof bVal === 'number') {
          comparison = aVal - bVal;
      } else if (typeof aVal === 'string' && typeof bVal === 'string') {
          comparison = aVal.localeCompare(bVal);
      } else {
          comparison = String(aVal).localeCompare(String(bVal));
      }
      return state.sortDirection === 'asc' ? comparison : -comparison;
    });
  }

  return `
    <div class="json-table">
      <table>
        <thead>
          <tr>
            <th class="row-number"><div>#</div></th>
            ${state.visibleColumns.map(col => {
              let removeButtonHtml = '';
              const draggableAttribute = state.editModeActive ? 'draggable="true"' : '';
              const thStyles = state.editModeActive ? 'cursor: grab;' : '';
              if (state.editModeActive) {
                  removeButtonHtml = `
                    <button 
                        class="remove-col-btn-header" 
                        data-action="remove-column-header" 
                        data-column="${encodeURIComponent(col)}"
                        aria-label="Remove column '${escapeStringForDataAttribute(col)}'" 
                        title="Remove column '${escapeStringForDataAttribute(col)}'" 
                    >−</button>`;
              }
              return `
              <th 
                role="button"
                tabindex="0"
                data-action="sort" 
                data-column="${encodeURIComponent(col)}" 
                class="${state.sortBy === col ? `sorted ${state.sortDirection}` : ''} ${col.toLowerCase() === 'id' ? 'col-id' : ''}"
                ${draggableAttribute}
                style="${thStyles}"
                aria-sort="${state.sortBy === col ? (state.sortDirection === 'asc' ? 'ascending' : 'descending') : 'none'}"
              >
                <div>
                  ${col}
                  ${removeButtonHtml}
                </div>
                ${state.showPaths ? `<div class="path-display">${col}</div>` : ''}
              </th>
            `}).join('')}
          </tr>
        </thead>
        <tbody>
          ${sortedData.map((row, index) => {
            const originalRowIndex = state.data.indexOf(row); 
            return `
            <tr>
              <td class="row-number"><div>${index + 1}</div></td>
              ${state.visibleColumns.map(col => 
                renderCell(getValue(row, col), col, originalRowIndex, false) 
              ).join('')}
            </tr>
          `}).join('')}
        </tbody>
      </table>
    </div>
  `;
};
  
const renderSqlModal = () => {
  if (!state.showSqlModal) return '';
  return `
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="sql-modal-title">
      <div id="sql-modal-content-wrapper" class="modal-content" style="width: 900px;">
        <div class="modal-header">
          <h3 id="sql-modal-title">Generated SQL</h3>
          <div>
            <select data-action="change-dialect" style="margin-right: 10px;">
              <option value="snowflake" ${state.sqlDialect === 'snowflake' ? 'selected' : ''}>Snowflake</option>
              <option value="postgresql" ${state.sqlDialect === 'postgresql' ? 'selected' : ''}>PostgreSQL</option>
            </select>
            <button data-action="copy-sql" style="margin-right: 10px;">Copy</button>
            <button class="close-btn" data-action="close-sql" aria-label="Close SQL modal">×</button>
          </div>
        </div>
        <textarea class="sql-output" readonly>${generateSQL(state.visibleColumns, state.sqlDialect)}</textarea>
      </div>
    </div>
  `;
};

const renderJsonModal = () => {
  if (!state.showJsonModal) return '';
  return `
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="json-modal-title">
      <div id="json-modal-content" class="modal-content" style="width: 900px; height: 80vh; display: flex; flex-direction: column;">
        <div class="modal-header">
          <h3 id="json-modal-title">Raw Data (JSON, CSV, TSV)</h3>
          <button class="close-btn" data-action="close-json" aria-label="Close raw data modal">×</button>
        </div>
        <textarea 
            id="json-edit-area" 
            class="json-edit-output" 
            aria-label="Raw JSON, CSV, or TSV editor"
            style="flex-grow: 1; width: 100%; resize: none; margin-bottom: 10px; font-family: 'Consolas', monospace;"
            placeholder="Paste JSON, CSV, or TSV data here, or load from file."
        >${state.rawJsonEditContent}</textarea>
        <div class="modal-footer" style="display: flex; justify-content: space-between; align-items: center; padding-top:10px; border-top: 1px solid #eee;">
          <div class="json-modal-actions-left">
            <input type="file" id="json-file-input" accept=".json,.csv,.tsv,.txt" style="display: none;">
            <button data-action="trigger-file-load" style="margin-right: 10px;">Load File</button>
            <button data-action="select-all-json" style="margin-right: 10px;">Select All</button>
            <button data-action="copy-json" style="margin-right: 10px;">Copy</button>
            <button data-action="clear-json" style="margin-right: 10px;">Clear</button>
            <button data-action="validate-json">Validate JSON</button>
          </div>
          <div class="json-modal-actions-right">
              <button data-action="apply-json-changes" style="margin-left: 10px; background-color: #28a745; color:white; border:none; padding: 8px 12px; border-radius:4px; cursor:pointer;">Apply & Close</button>
          </div>
        </div>
         <span class="json-validation-status" role="status" aria-live="polite" aria-atomic="true" style="font-size: 12px; min-height: 1.2em; margin-top: 5px; text-align: right;">${state.jsonValidationMessage}</span>
      </div>
    </div>
  `;
};

const renderPromoteKeyPopover = () => {
  if (!state.showPromoteKeyPopover || !state.promoteKeyPopoverContext) {
      return '';
  }
  const { targetElementRect, pathToArrayElement, valueFieldName, siblingKeysAndValues } = state.promoteKeyPopoverContext;
  const popoverTop = targetElementRect.bottom + window.scrollY + 5;
  const popoverLeft = targetElementRect.left + window.scrollX;
  const popoverStyle = `
      position: absolute; top: ${popoverTop}px; left: ${popoverLeft}px;
      background-color: white; border: 1px solid #ccc; border-radius: 4px;
      padding: 10px; z-index: 1050; box-shadow: 0 2px 10px rgba(0,0,0,0.15);
      font-size: 0.9em; min-width: 200px;
  `;
  const arrayName = pathToArrayElement.substring(0, pathToArrayElement.lastIndexOf('['));
  const itemIdentifierInArray = pathToArrayElement.substring(pathToArrayElement.lastIndexOf('['));
  let content = `<div style="margin-bottom: 8px; font-weight: bold;">Promote field: <code>${valueFieldName}</code></div>`;
  content += `<div style="margin-bottom: 8px; font-size: 0.9em;">From item in <code>${arrayName}</code>. Identify this item by:</div>`;
  content += '<ul style="list-style: none; padding: 0; margin: 0;">';
  siblingKeysAndValues.forEach(skv => {
      let displayValue = String(skv.value);
      if (displayValue.length > 25) displayValue = displayValue.substring(0, 22) + "...";
      content += `
          <li style="margin-bottom: 5px;">
              <button class="promote-popover-btn" data-action="confirm-promote-with-key" data-selected-key="${escapeStringForDataAttribute(skv.key)}">
                  ${skv.key}: "${escapeStringForDataAttribute(displayValue)}"
              </button>
          </li>`;
  });
  content += `
      <li style="margin-bottom: 5px;">
          <button class="promote-popover-btn" data-action="confirm-promote-with-key" data-selected-key="INDEX">
              Original position (<code>${itemIdentifierInArray}</code>)
          </button>
      </li>
      <li style="margin-top: 10px; border-top: 1px solid #eee; padding-top: 8px;">
          <button class="promote-popover-btn promote-popover-cancel-btn" data-action="cancel-promote-popover">Cancel</button>
      </li>
  </ul>`;
  return `<div id="promote-key-popover" class="promote-key-popover" style="${popoverStyle}" role="dialog" aria-modal="true" aria-labelledby="promote-key-popover-title">
              <h4 id="promote-key-popover-title" class="sr-only">Promote Key Options</h4>
              ${content}
          </div>`;
};

const renderAddColumnPopover = () => {
  if (!state.showAddColumnPopover || !state.addColumnPopoverAnchor) return '';
  const anchorRect = state.addColumnPopoverAnchor.getBoundingClientRect();
  const popoverTop = anchorRect.bottom + window.scrollY + 5;
  const popoverWidth = 250;
  let popoverLeft = anchorRect.left + window.scrollX;
  if (popoverLeft + popoverWidth > window.innerWidth) popoverLeft = anchorRect.right + window.scrollX - popoverWidth;
  popoverLeft = Math.max(0, popoverLeft);
  const popoverStyle = `
      position: absolute; top: ${popoverTop}px; left: ${popoverLeft}px;
      background-color: white; border: 1px solid #ccc; border-radius: 4px;
      padding: 10px; z-index: 1050; box-shadow: 0 2px 10px rgba(0,0,0,0.15);
      font-size: 0.9em; min-width: ${popoverWidth}px; max-height: 300px; overflow-y: auto;
  `;
  const availableColumnsToAdd = [...state.allPossibleColumns].filter(
      col => !state.visibleColumns.includes(col)
  ).sort((a,b) => a.localeCompare(b, undefined, {sensitivity: 'base'}));
  let content = `<div style="margin-bottom: 8px; font-weight: bold; padding-bottom: 5px; border-bottom: 1px solid #eee;">Available Columns to Add</div>`;
  if (availableColumnsToAdd.length === 0) {
      content += '<div style="padding: 5px 0;"><i>No more columns to add.</i></div>';
  } else {
      content += '<ul style="list-style: none; padding: 0; margin: 0;">';
      availableColumnsToAdd.forEach(col => {
          content += `
              <li style="margin-bottom: 5px;">
                  <button class="add-column-popover-btn" data-action="add-column-from-popover" data-column-to-add="${escapeStringForDataAttribute(col)}" title="Add column: ${escapeStringForDataAttribute(col)}">
                     + ${escapeStringForDataAttribute(col)}
                  </button>
              </li>`;
      });
      content += '</ul>';
  }
  content += `
      <div style="margin-top: 10px; border-top: 1px solid #eee; padding-top: 8px; text-align: right;">
          <button class="add-column-popover-cancel-btn" data-action="cancel-add-column-popover">Close</button>
      </div>
  `;
  return `<div id="add-column-popover" class="add-column-popover" style="${popoverStyle}" role="dialog" aria-modal="true" aria-labelledby="add-column-popover-title">
              <h4 id="add-column-popover-title" class="sr-only">Reinstate Column</h4>
              ${content}
          </div>`;
};

// Drag-and-drop state
let dragSourceElement = null;

// Drag-and-Drop Handlers for Column Reordering
function handleThDragStart(e) {
  if (!state.editModeActive) return;
  this.classList.add('dragging');
  dragSourceElement = this;
  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/plain', this.dataset.column);
}

function handleThDragOver(e) {
  if (!state.editModeActive || !dragSourceElement) return;
  e.preventDefault();
  e.dataTransfer.dropEffect = 'move';
  if (this !== dragSourceElement) this.classList.add('drag-over');
  return false;
}

function handleThDragEnter(e) {
  if (!state.editModeActive || !dragSourceElement) return;
  e.preventDefault();
  if (this !== dragSourceElement) this.classList.add('drag-over');
}

function handleThDragLeave() {
  if (!state.editModeActive) return;
  this.classList.remove('drag-over');
}

function handleThDrop(e) {
  if (!state.editModeActive || !dragSourceElement) return;
  e.stopPropagation(); 
  e.preventDefault();  
  this.classList.remove('drag-over');
  if (dragSourceElement !== this) {
      const sourceColumnEncoded = e.dataTransfer.getData('text/plain');
      const targetColumnEncoded = this.dataset.column;
      const sourceColumn = decodeURIComponent(sourceColumnEncoded);
      const targetColumn = decodeURIComponent(targetColumnEncoded);
      const currentCols = [...state.visibleColumns];
      const sourceIndex = currentCols.indexOf(sourceColumn);
      const targetIndex = currentCols.indexOf(targetColumn);
      if (sourceIndex !== -1 && targetIndex !== -1 && sourceIndex !== targetIndex) {
          const [movedItem] = currentCols.splice(sourceIndex, 1); 
          currentCols.splice(targetIndex, 0, movedItem);          
          state.visibleColumns = currentCols; 
      }
  }
  return false;
}

function handleThDragEnd() {
  if (!state.editModeActive) return;
  this.classList.remove('dragging');
  const tableHead = this.closest('thead');
  if (tableHead) {
      tableHead.querySelectorAll('th.drag-over').forEach(th => th.classList.remove('drag-over'));
  }
  dragSourceElement = null; 
}

const render = () => {
  const appElement = document.getElementById('app');
  if (!appElement) return;
  
  const activeElement = document.activeElement;
  let activeElementId = activeElement ? activeElement.id : null;
  let selectionStart, selectionEnd;

  if (activeElement && (activeElement.id === 'json-browser-search-box' || activeElement.id === 'json-edit-area')) {
      selectionStart = activeElement.selectionStart;
      selectionEnd = activeElement.selectionEnd;
  }

  const jsonTableElement = appElement.querySelector('.json-table');
  let mainScrollLeft = 0;
  let mainScrollTop = 0;

  if (jsonTableElement) {
      mainScrollLeft = jsonTableElement.scrollLeft; 
      mainScrollTop = jsonTableElement.scrollTop;
  }
  
  appElement.innerHTML = `
    ${renderHeader()}
    ${renderTable()}
    ${renderSqlModal()} 
    ${renderJsonModal()}
    ${renderPromoteKeyPopover()}
    ${renderAddColumnPopover()} 
    ${renderCsvModal()} 
  `;

  if (state.showJsonModal) {
      const jsonEditArea = document.getElementById('json-edit-area');
      const modalContentElement = document.getElementById('json-modal-content'); 
      const modalContentTarget = modalContentElement || jsonEditArea;
      
      if (modalContentTarget && !modalContentTarget.dataset.dndListenersAttached) {
          modalContentTarget.dataset.dndListenersAttached = 'true';
          const dragOverHandler = (e) => { e.preventDefault(); e.stopPropagation(); e.dataTransfer.dropEffect = 'copy'; modalContentTarget.classList.add('drag-over-active'); };
          const dragLeaveHandler = (e) => { e.preventDefault(); e.stopPropagation(); modalContentTarget.classList.remove('drag-over-active'); };
          const dropHandler = (e) => {
              e.preventDefault(); e.stopPropagation(); modalContentTarget.classList.remove('drag-over-active');
              const files = e.dataTransfer.files;
              if (files.length > 0) {
                  const file = files[0];
                  const reader = new FileReader();
                  reader.onload = (loadEvent) => {
                      state.rawJsonEditContent = loadEvent.target.result;
                      state.jsonValidationMessage = 'File dropped. Validate or Apply & Close.';
                      if (jsonEditArea) jsonEditArea.value = state.rawJsonEditContent;
                  };
                  reader.onerror = () => { state.jsonValidationMessage = '<span style="color: red;">Error reading dropped file.</span>'; };
                  reader.readAsText(file);
              }
          };
          modalContentTarget.addEventListener('dragover', dragOverHandler);
          modalContentTarget.addEventListener('dragleave', dragLeaveHandler);
          modalContentTarget.addEventListener('drop', dropHandler);
          modalContentTarget._dndHandlers = { dragOverHandler, dragLeaveHandler, dropHandler };
      }
  } else {
      const modalContentTarget = document.getElementById('json-modal-content') || document.getElementById('json-edit-area');
      if (modalContentTarget && modalContentTarget.dataset.dndListenersAttached) {
          if (modalContentTarget._dndHandlers) {
              modalContentTarget.removeEventListener('dragover', modalContentTarget._dndHandlers.dragOverHandler);
              modalContentTarget.removeEventListener('dragleave', modalContentTarget._dndHandlers.dragLeaveHandler);
              modalContentTarget.removeEventListener('drop', modalContentTarget._dndHandlers.dropHandler);
              delete modalContentTarget._dndHandlers;
          }
          delete modalContentTarget.dataset.dndListenersAttached;
          modalContentTarget.classList.remove('drag-over-active');
      }
  }

  const newJsonTableElement = appElement.querySelector('.json-table');
  if (newJsonTableElement) {
      if (mainScrollTop !== undefined) newJsonTableElement.scrollTop = mainScrollTop;
      if (mainScrollLeft !== undefined) newJsonTableElement.scrollLeft = mainScrollLeft; 
  }

  if (state.editModeActive) {
      const thElements = appElement.querySelectorAll('table > thead > tr > th[data-column][draggable="true"]');
      thElements.forEach(th => {
          th.addEventListener('dragstart', handleThDragStart);
          th.addEventListener('dragenter', handleThDragEnter);
          th.addEventListener('dragover', handleThDragOver);
          th.addEventListener('dragleave', handleThDragLeave);
          th.addEventListener('drop', handleThDrop);
          th.addEventListener('dragend', handleThDragEnd);
      });
  }

  if (activeElementId) {
      const newActiveElement = document.getElementById(activeElementId);
      if (newActiveElement && document.activeElement !== newActiveElement) { 
          newActiveElement.focus();
          if ((activeElementId === 'json-browser-search-box' || activeElementId === 'json-edit-area') && 
              selectionStart !== undefined && selectionEnd !== undefined) {
              try { newActiveElement.setSelectionRange(selectionStart, selectionEnd); } catch (ex) { /* ignore */ }
          }
      }
  }
  if (state.showJsonModal) {
      const jsonEditArea = document.getElementById('json-edit-area');
      if (jsonEditArea && jsonEditArea.value !== state.rawJsonEditContent) {
          jsonEditArea.value = state.rawJsonEditContent; 
          if (activeElementId === 'json-edit-area' && document.getElementById(activeElementId) === jsonEditArea) {
               try { jsonEditArea.setSelectionRange(selectionStart, selectionEnd); } catch (ex) {/* ignore */}
          }
      }
  }
};

// --- END OF INLINED ui.js ---

// --- START OF INLINED basic.js (entry point) ---

// basic.js (new main entry point)

const handleKeyboard = (e) => {
  const searchBoxFocused = e.target.matches('.search-box') || e.target.id === 'json-browser-search-box';
  const jsonEditAreaFocused = e.target.id === 'json-edit-area';
  const inModal = e.target.closest('.modal');
  const inPromotePopover = e.target.closest('#promote-key-popover');
  const inAddColumnPopover = e.target.closest('#add-column-popover');

  if (searchBoxFocused) {
    if (e.key === 'Enter') {
      e.preventDefault(); 
      if (state.searchQuery !== e.target.value) {
           state.searchQuery = e.target.value;
      }
      if (state.searchQuery.trim() === '') {
          state.searchResults = [];
          state.currentSearchIndex = -1;
          return;
      }
      state.searchResults = performSearch(state.data, state.searchQuery);
      state.currentSearchIndex = state.searchResults.length > 0 ? 0 : -1;
      if (state.searchResults.length > 0) {
          expandToResult(state.searchResults[state.currentSearchIndex]); 
      }
    } else if (e.key === 'Escape') {
      e.preventDefault(); 
      state.searchQuery = '';
      e.target.value = ''; 
      state.searchResults = [];
      state.currentSearchIndex = -1;
    }
  }
  
  if (e.key === 'Escape') {
      if (state.showAddColumnPopover) { 
          e.preventDefault();
          const cancelButton = document.querySelector('#add-column-popover .add-column-popover-cancel-btn');
          if (cancelButton) cancelButton.click();
          else {
              closeModalFocus('#add-column-popover');
              state.showAddColumnPopover = false;
              if (state.addColumnPopoverAnchor) state.addColumnPopoverAnchor.focus();
              state.addColumnPopoverAnchor = null;
          }
      } else if (state.showPromoteKeyPopover) {
          e.preventDefault();
          const cancelButton = document.querySelector('#promote-key-popover .promote-popover-cancel-btn');
          if (cancelButton) cancelButton.click();
          else {
              closeModalFocus('#promote-key-popover');
              state.showPromoteKeyPopover = false;
              if (state.promoteKeyPopoverContext && state.promoteKeyPopoverContext.triggerElement) {
                  state.promoteKeyPopoverContext.triggerElement.focus();
              }
              state.promoteKeyPopoverContext = null;
          }
      } else if (state.showSqlModal && inModal) {
          e.preventDefault();
          closeModalFocus('.modal[aria-labelledby="sql-modal-title"]');
          state.showSqlModal = false;
      } else if (state.showJsonModal && inModal && !jsonEditAreaFocused) {
          e.preventDefault();
          closeModalFocus('.modal[aria-labelledby="json-modal-title"]');
          state.showJsonModal = false;
          state.jsonValidationMessage = '';
      } else if (state.editModeActive && !searchBoxFocused && !jsonEditAreaFocused && !inModal && !inPromotePopover && !inAddColumnPopover) { 
          e.preventDefault();
          state.editModeActive = false;
      }
  }

  if ((e.key === 'Enter' || e.key === ' ') && 
      (e.target.matches('.expandable[role="button"]') || e.target.matches('th[role="button"]'))) {
      e.preventDefault();
      e.target.click(); 
  }
};
  
const handleEvent = (e) => {
  const eventTarget = e.target; 
  
  if (state.showAddColumnPopover) {
      const popoverElement = document.querySelector('#add-column-popover');
      const clickedAddColumnButton = eventTarget.closest('[data-action="show-add-column-popover"]');
      const clickedInsidePopover = popoverElement && popoverElement.contains(eventTarget);
      if (!clickedInsidePopover && !clickedAddColumnButton) {
          const cancelButton = document.querySelector('#add-column-popover .add-column-popover-cancel-btn');
          if (cancelButton) cancelButton.click();
          else {
              closeModalFocus('#add-column-popover');
              state.showAddColumnPopover = false;
              if(state.addColumnPopoverAnchor) state.addColumnPopoverAnchor.focus();
              state.addColumnPopoverAnchor = null;
          }
      }
  }
  if (state.showPromoteKeyPopover) {
      const popoverElement = document.querySelector('#promote-key-popover');
      const clickedPromoteButton = eventTarget.closest('[data-action="promote-value"]');
      const clickedInsidePopover = popoverElement && popoverElement.contains(eventTarget);
      if (!clickedInsidePopover && !clickedPromoteButton) {
          const cancelButton = document.querySelector('#promote-key-popover .promote-popover-cancel-btn');
           if (cancelButton) cancelButton.click();
           else {
              closeModalFocus('#promote-key-popover');
              state.showPromoteKeyPopover = false;
              if(state.promoteKeyPopoverContext && state.promoteKeyPopoverContext.triggerElement) {
                   state.promoteKeyPopoverContext.triggerElement.focus();
              }
              state.promoteKeyPopoverContext = null;
           }
      }
  }

  let target = eventTarget; 
  let action = target.dataset.action;

  if (!action && target.closest('[data-action]')) {
      target = target.closest('[data-action]');
      action = target.dataset.action;
  }
  if (!action) return; 

  const { path, row, column } = target.dataset; 
  
  switch (action) {
    case 'search': 
      if (state.searchQuery !== target.value) { 
        state.searchQuery = target.value;
        if (state.searchQuery === '') {
            state.searchResults = [];
            state.currentSearchIndex = -1;
        }
      }
      break;
    case 'search-next':
      if (state.searchResults.length > 0) {
        state.currentSearchIndex = (state.currentSearchIndex + 1) % state.searchResults.length;
        expandToResult(state.searchResults[state.currentSearchIndex]); 
      }
      break;
    case 'search-prev':
      if (state.searchResults.length > 0) {
        state.currentSearchIndex = (state.currentSearchIndex - 1 + state.searchResults.length) % state.searchResults.length;
        expandToResult(state.searchResults[state.currentSearchIndex]); 
      }
      break;
    case 'toggle':
      const expandKey = `${row}-${path}`; 
      if (state.expandedPaths.has(expandKey)) state.expandedPaths.delete(expandKey);
      else state.expandedPaths.add(expandKey);
      state.notify('expandedPaths'); 
      break;
    case 'expand-all':
      state.data.forEach((rowData, rowIndex) => {
        getAllObjectPaths(rowData).forEach(itemPath => state.expandedPaths.add(`${rowIndex}-${itemPath}`));
      });
      state.notify('expandedPaths');
      break;
    case 'collapse-all':
      state.expandedPaths.clear();
      state.notify('expandedPaths');
      break;
    case 'toggle-paths':
      state.showPaths = !state.showPaths;
      break;
    case 'toggle-edit-mode':
      state.editModeActive = !state.editModeActive;
      if (!state.editModeActive) { 
          if (state.showPromoteKeyPopover) { state.showPromoteKeyPopover = false; state.promoteKeyPopoverContext = null; }
          if (state.showAddColumnPopover) { state.showAddColumnPopover = false; state.addColumnPopoverAnchor = null; }
      }
      break;
    case 'promote-value':
      const pathClicked = target.dataset.pathToValue; 
      const rowIndexForContext = parseInt(target.dataset.rowIndex);
      const rowData = state.data[rowIndexForContext]; 
      const lastDotIndex = pathClicked.lastIndexOf('.');
      if (lastDotIndex === -1) { 
          if (!state.visibleColumns.includes(pathClicked)) {
              state.visibleColumns = [...state.visibleColumns, pathClicked];
              updateAllPossibleColumns(); 
          }
          if (state.showPromoteKeyPopover) { state.showPromoteKeyPopover = false; state.promoteKeyPopoverContext = null; }
          break; 
      }
      const parentObjectPath = pathClicked.substring(0, lastDotIndex); 
      const fieldName = pathClicked.substring(lastDotIndex + 1);      
      const arrayElementMatch = parentObjectPath.match(/^(.*)\[(\d+)\]$/); 
      if (arrayElementMatch) { 
          const pathToArrayElement = parentObjectPath; 
          const objectInArray = getValue(rowData, pathToArrayElement);
          if (objectInArray && typeof objectInArray === 'object' && !Array.isArray(objectInArray)) {
              const siblingKeysAndValues = [];
              for (const key in objectInArray) {
                  const val = objectInArray[key];
                  if (typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean') {
                      siblingKeysAndValues.push({ key, value: val });
                  }
              }
              if (siblingKeysAndValues.length > 0) {
                  state.promoteKeyPopoverContext = {
                      rowIndex: rowIndexForContext, originalPathToValue: pathClicked,    
                      pathToArrayElement: pathToArrayElement, valueFieldName: fieldName,           
                      targetElementRect: target.getBoundingClientRect(), siblingKeysAndValues,
                      triggerElement: target,
                  };
                  state.showPromoteKeyPopover = true;
                  return; 
              }
          }
      }
      if (!state.visibleColumns.includes(pathClicked)) {
          state.visibleColumns = [...state.visibleColumns, pathClicked];
          updateAllPossibleColumns(); 
      }
      if (state.showPromoteKeyPopover) { state.showPromoteKeyPopover = false; state.promoteKeyPopoverContext = null; }
      break;
    case 'confirm-promote-with-key':
      if (!state.promoteKeyPopoverContext) break;
      const { rowIndex, originalPathToValue, pathToArrayElement, valueFieldName, triggerElement: promoteTrigger } = state.promoteKeyPopoverContext;
      const selectedKeyForId = target.dataset.selectedKey; 
      const rowDataForPromotion = state.data[rowIndex];
      let pathToPromote;
      if (selectedKeyForId === 'INDEX') {
          pathToPromote = originalPathToValue; 
      } else {
          const arrayBasePath = pathToArrayElement.substring(0, pathToArrayElement.lastIndexOf('[')); 
          const objectInArray = getValue(rowDataForPromotion, pathToArrayElement); 
          if (objectInArray && typeof objectInArray === 'object' && objectInArray.hasOwnProperty(selectedKeyForId)) {
              const identifyingKeyValue = String(objectInArray[selectedKeyForId]);
              const safeIdentifyingKeyValue = identifyingKeyValue.replace(/"/g, '\\"'); 
              pathToPromote = `${arrayBasePath}[${selectedKeyForId}="${safeIdentifyingKeyValue}"].${valueFieldName}`;
          } else {
              pathToPromote = originalPathToValue;
              console.warn("Could not find selected key for promotion, falling back to index path.");
          }
      }
      if (!state.visibleColumns.includes(pathToPromote)) {
          state.visibleColumns = [...state.visibleColumns, pathToPromote];
          updateAllPossibleColumns(); 
      }
      closeModalFocus('#promote-key-popover');
      state.showPromoteKeyPopover = false;
      state.promoteKeyPopoverContext = null;
      if (promoteTrigger) requestAnimationFrame(() => promoteTrigger.focus());
      break;
    case 'cancel-promote-popover':
      const promoteAnchor = state.promoteKeyPopoverContext ? state.promoteKeyPopoverContext.triggerElement : null;
      closeModalFocus('#promote-key-popover');
      state.showPromoteKeyPopover = false;
      state.promoteKeyPopoverContext = null;
      if (promoteAnchor) requestAnimationFrame(() => promoteAnchor.focus());
      break;
    case 'sort':
        const sortColumn = decodeURIComponent(column); 
        if (state.sortBy === sortColumn) state.sortDirection = state.sortDirection === 'asc' ? 'desc' : 'asc';
        else { state.sortBy = sortColumn; state.sortDirection = 'asc'; }
        break;
    case 'remove-column-header': 
        const colToRemove = decodeURIComponent(target.dataset.column);
        state.visibleColumns = state.visibleColumns.filter(c => c !== colToRemove);
        if (state.sortBy === colToRemove) state.sortBy = null; 
        break;
    case 'show-sql': state.showSqlModal = true; break;
    case 'close-sql': closeModalFocus('.modal[aria-labelledby="sql-modal-title"]'); state.showSqlModal = false; break;
    case 'change-dialect': state.sqlDialect = target.value; break;
    case 'copy-sql':
      { 
        const sqlOutputElement = document.querySelector('.sql-output');
        if (sqlOutputElement) {
          navigator.clipboard.writeText(sqlOutputElement.value).then(() => {
            target.textContent = 'Copied!'; setTimeout(() => target.textContent = 'Copy', 2000);
          }).catch(err => {
              console.error('Failed to copy SQL: ', err);
              target.textContent = 'Failed!'; setTimeout(() => target.textContent = 'Copy', 2000);
          });
        }
      }
      break;
    case 'show-json': 
      if (!state.showJsonModal) { 
        try {
          state.rawJsonEditContent = state.data.length > 0 ? JSON.stringify(state.data, null, 2) : '';
        } catch (e) {
           console.error("Error stringifying data for JSON modal:", e);
           state.rawJsonEditContent = "Error: Could not serialize current data. Please clear and paste new data.";
        }
        state.jsonValidationMessage = state.data.length === 0 ? 'Paste or load data.' : '';
      }
      state.showJsonModal = true;
      break;
    case 'close-json':
      closeModalFocus('.modal[aria-labelledby="json-modal-title"]');
      state.showJsonModal = false; state.jsonValidationMessage = ''; 
      break;
    case 'trigger-file-load':
      document.getElementById('json-file-input')?.click();
      break;
    case 'clear-json':
      state.rawJsonEditContent = '';
      const jsonEditAreaForClear = document.getElementById('json-edit-area');
      if (jsonEditAreaForClear) jsonEditAreaForClear.value = '';
      state.jsonValidationMessage = 'Paste or load data.';
      break;
    case 'select-all-json':
      const jsonEditAreaSelect = document.getElementById('json-edit-area');
      if (jsonEditAreaSelect) { jsonEditAreaSelect.focus(); jsonEditAreaSelect.select(); }
      break;
    case 'copy-json':
      const jsonEditAreaCopy = document.getElementById('json-edit-area');
      if (jsonEditAreaCopy) {
          navigator.clipboard.writeText(jsonEditAreaCopy.value).then(() => {
              state.jsonValidationMessage = '<span style="color: green;">Copied to clipboard!</span>';
          }).catch(err => {
              console.error('Failed to copy JSON: ', err);
              state.jsonValidationMessage = '<span style="color: red;">Failed to copy.</span>';
          });
      }
      break;
    case 'validate-json': 
      try {
        const jsonEditAreaVal = document.getElementById('json-edit-area');
        const currentTextVal = jsonEditAreaVal ? jsonEditAreaVal.value : state.rawJsonEditContent;
        const parsedJson = JSON.parse(currentTextVal);
        state.rawJsonEditContent = JSON.stringify(parsedJson, null, 2); 
        state.jsonValidationMessage = '<span style="color: green;">JSON is valid.</span>';
      } catch (err) {
        state.jsonValidationMessage = `<span style="color: red;">Invalid JSON: ${err.message}</span>`;
      }
      break;
    case 'apply-json-changes':
      {
          const jsonEditAreaApply = document.getElementById('json-edit-area');
          const currentTextApply = jsonEditAreaApply ? jsonEditAreaApply.value : state.rawJsonEditContent; 
          let parsedData = null; let parseMethod = ''; let detectedHeaders = [];
          robustParseCSV.lastHeaders = []; 
          if (currentTextApply.trim() === '') { parsedData = []; parseMethod = 'empty'; }
          else {
              try {
                  const jsonData = JSON.parse(currentTextApply); 
                  if (Array.isArray(jsonData)) { parsedData = jsonData; parseMethod = 'JSON'; }
                  else if (typeof jsonData === 'object' && jsonData !== null) { parsedData = [jsonData]; parseMethod = 'JSON (single object)';}
              } catch (e) { /* JSON parse failed */ }
              if (parsedData === null) {
                  try {
                      const delimiter = detectDelimiter(currentTextApply.substring(0, Math.min(currentTextApply.length, 2000)));
                      const csvObjects = robustParseCSV(currentTextApply, delimiter); 
                      detectedHeaders = robustParseCSV.lastHeaders; 
                      if (csvObjects.length > 0 || (detectedHeaders.length > 0 && detectedHeaders.some(h => h !== ''))) {
                         parsedData = csvObjects; parseMethod = delimiter === '\t' ? 'TSV' : 'CSV';
                         if (csvObjects.length === 0 && detectedHeaders.length > 0) parseMethod += ' (headers only)';
                      }
                  } catch (csvErr) { console.error("CSV parsing error during apply:", csvErr); }
              }
          }
          if (parsedData !== null) {
              state.data = parsedData;
              closeModalFocus('.modal[aria-labelledby="json-modal-title"]'); 
              state.showJsonModal = false; state.jsonValidationMessage = '';
              let newVisibleColumns = [];
              if (detectedHeaders.length > 0) newVisibleColumns = detectedHeaders;
              else if (state.data.length > 0 && typeof state.data[0] === 'object' && state.data[0] !== null) newVisibleColumns = Object.keys(state.data[0]);
              state.visibleColumns = newVisibleColumns;
              updateAllPossibleColumns(); 
              state.searchQuery = ''; state.searchResults = []; state.currentSearchIndex = -1;
              state.expandedPaths.clear(); state.sortBy = null;
              state.notify('data'); 
              console.log(`Data applied successfully using ${parseMethod} parser.`);
          } else {
              state.jsonValidationMessage = '<span style="color: red;">Cannot apply: Invalid data format. Not recognized as JSON, CSV, or TSV.</span>';
          }
      }
      break;
    case 'show-add-column-popover':
      state.addColumnPopoverAnchor = target; state.showAddColumnPopover = true;
      break;
    case 'cancel-add-column-popover':
      const addColumnAnchor = state.addColumnPopoverAnchor;
      closeModalFocus('#add-column-popover');
      state.showAddColumnPopover = false; state.addColumnPopoverAnchor = null;
      if (addColumnAnchor) requestAnimationFrame(() => addColumnAnchor.focus());
      break;
    case 'add-column-from-popover':
      const columnToAdd = target.dataset.columnToAdd;
      if (columnToAdd && !state.visibleColumns.includes(columnToAdd)) {
          state.visibleColumns = [...state.visibleColumns, columnToAdd];
      }
      break;
    case 'reset-view':
      state.searchQuery = '';
      const searchBox = document.getElementById('json-browser-search-box');
      if (searchBox) searchBox.value = '';
      state.searchResults = []; state.currentSearchIndex = -1;
      state.sortBy = null; state.expandedPaths.clear();
      let resetToColumns = [];
      if (robustParseCSV.lastHeaders && robustParseCSV.lastHeaders.length > 0 && robustParseCSV.lastHeaders.some(h => h && h.trim() !== '')) {
          resetToColumns = robustParseCSV.lastHeaders.filter(h => h && h.trim() !== '');
      } 
      else if (state.data.length > 0 && state.data[0] && typeof state.data[0] === 'object' && state.data[0] !== null) {
          resetToColumns = Object.keys(state.data[0]);
      }
      state.visibleColumns = [...resetToColumns];
      updateAllPossibleColumns(); 
      break;    
    case 'show-csv':
      state.csvOutputContent = generateCSV(); state.showCsvModal = true;
      break;
    case 'close-csv':
      closeModalFocus('.modal[aria-labelledby="csv-modal-title"]'); state.showCsvModal = false;
      break;
    case 'copy-csv':
      {
        const csvOutputArea = document.getElementById('csv-output-area');
        if (csvOutputArea) {
          navigator.clipboard.writeText(csvOutputArea.value).then(() => {
            target.textContent = 'Copied!'; setTimeout(() => { target.textContent = 'Copy CSV'; }, 2000);
          }).catch(err => {
            console.error('Failed to copy CSV: ', err);
            target.textContent = 'Failed!'; setTimeout(() => { target.textContent = 'Copy CSV'; }, 2000);
          });
        }
      }
      break;
    case 'download-csv':
      {
        const blob = new Blob([state.csvOutputContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        if (link.download !== undefined) {
          const url = URL.createObjectURL(blob);
          link.setAttribute("href", url); link.setAttribute("download", "export.csv");
          link.style.visibility = 'hidden'; document.body.appendChild(link);
          link.click(); document.body.removeChild(link); URL.revokeObjectURL(url);
        } else {
          alert("CSV download not supported. Please use 'Copy CSV'.");
        }
      }
      break;
  }
};

const init = async () => {
  try {
    let rawDataInput; let dataSuccessfullyLoaded = false;
    robustParseCSV.lastHeaders = []; 
    if (typeof jsonData !== 'undefined') { rawDataInput = jsonData; console.log("Global `jsonData` found."); }
    else { rawDataInput = null; console.log("Global `jsonData` not found."); }

    if (rawDataInput !== null) {
      if (Array.isArray(rawDataInput)) { state.data = rawDataInput; dataSuccessfullyLoaded = true; }
      else if (typeof rawDataInput === 'string') {
          try {
              const parsedJsonAttempt = JSON.parse(rawDataInput);
              if (Array.isArray(parsedJsonAttempt)) state.data = parsedJsonAttempt;
              else if (typeof parsedJsonAttempt === 'object' && parsedJsonAttempt !== null) state.data = [parsedJsonAttempt];
              else {
                  const delimiter = detectDelimiter(rawDataInput.substring(0, Math.min(rawDataInput.length, 2000)));
                  state.data = robustParseCSV(rawDataInput, delimiter); 
              }
              dataSuccessfullyLoaded = true;
          } catch (e) {
              const delimiter = detectDelimiter(rawDataInput.substring(0, Math.min(rawDataInput.length, 2000)));
              state.data = robustParseCSV(rawDataInput, delimiter); 
              dataSuccessfullyLoaded = true; 
          }
      } else if (typeof rawDataInput === 'object' && rawDataInput !== null) { state.data = [rawDataInput]; dataSuccessfullyLoaded = true; }
    }
    if (!dataSuccessfullyLoaded || !Array.isArray(state.data)) state.data = []; 
    
    let initialVisible = [];
    if (robustParseCSV.lastHeaders && robustParseCSV.lastHeaders.length > 0) initialVisible = robustParseCSV.lastHeaders;
    else if (state.data.length > 0 && typeof state.data[0] === 'object' && state.data[0] !== null) initialVisible = Object.keys(state.data[0]);
    state.visibleColumns = initialVisible;
    updateAllPossibleColumns(); 

    if (state.data.length === 0 && typeof jsonData === 'undefined') { 
      state.showJsonModal = true; state.rawJsonEditContent = '';
      state.jsonValidationMessage = 'Paste JSON, CSV, or TSV data, or load from file.';
    }
    
    state.subscribe(() => {
        const wasSqlModalVisible = !!document.querySelector('.modal[aria-labelledby="sql-modal-title"]');
        const wasJsonModalVisible = !!document.querySelector('.modal[aria-labelledby="json-modal-title"]');
        const wasAddColumnPopoverVisible = state.showAddColumnPopover; 
        const wasPromotePopoverVisible = state.showPromoteKeyPopover;
        const wasCsvModalVisible = !!document.querySelector('.modal[aria-labelledby="csv-modal-title"]');
        render();
        if (state.showSqlModal && !wasSqlModalVisible) openModalFocus('.modal[aria-labelledby="sql-modal-title"]');
        if (state.showJsonModal && !wasJsonModalVisible) {
            const jsonModal = document.querySelector('.modal[aria-labelledby="json-modal-title"]');
            if (!jsonModal || !jsonModal.contains(document.activeElement)) openModalFocus('.modal[aria-labelledby="json-modal-title"]');
        }
        if (state.showAddColumnPopover && !wasAddColumnPopoverVisible) openModalFocus('#add-column-popover');
        if (state.showPromoteKeyPopover && !wasPromotePopoverVisible) openModalFocus('#promote-key-popover');
        if (state.showCsvModal && !wasCsvModalVisible) openModalFocus('.modal[aria-labelledby="csv-modal-title"]');
    }); 
    
    document.addEventListener('click', handleEvent);
    document.addEventListener('input', (e) => { 
      const target = e.target;
      if (target.id === 'json-browser-search-box' && target.value === '' && state.searchQuery !== '') { 
          state.searchQuery = ''; state.searchResults = []; state.currentSearchIndex = -1;
      } else if (target.id === 'json-edit-area') { 
          if (state.rawJsonEditContent !== target.value) state.rawJsonEditContent = target.value;
          if (state.jsonValidationMessage && (state.jsonValidationMessage.includes('red') || state.jsonValidationMessage.includes('green') || state.jsonValidationMessage.startsWith("Paste") || state.jsonValidationMessage.startsWith("File loaded") || state.jsonValidationMessage.startsWith("File dropped"))) {
              state.jsonValidationMessage = ''; 
          }
      }
    });
    document.addEventListener('change', (e) => { 
      const target = e.target;
      if (target?.dataset?.action === "change-dialect") handleEvent(e);
      else if (target.id === 'json-file-input') { 
          const file = target.files[0];
          if (file) {
              const reader = new FileReader();
              reader.onload = (loadEvent) => {
                  state.rawJsonEditContent = loadEvent.target.result;
                  state.jsonValidationMessage = 'File loaded. Validate JSON or Apply & Close.';
                  target.value = null; 
              };
              reader.onerror = () => {
                  state.jsonValidationMessage = '<span style="color: red;">Error reading file.</span>';
                  target.value = null; 
              };
              reader.readAsText(file);
          }
      }
    });
    document.addEventListener('keydown', handleKeyboard);
    render(); 
  } catch (error) {
    console.error('Initialization error:', error);
    const appElement = document.getElementById('app');
    if (appElement) appElement.innerHTML = `<div class="no-results" style="color: red; border: 1px solid red; padding: 20px;">Error: ${error.message}</div>`;
  }
};

if (typeof jsonData === 'undefined' && (document.readyState === 'loading' || document.readyState === 'interactive')) {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init(); 
}
// --- END OF INLINED basic.js (entry point) ---

</script>
</body>
</html>